{
    "docs": [
        {
            "location": "/", 
            "text": "JanICE API\n\n\nThe JanICE API is a \nC\n API that provides a common interface between computer vision\nalgorithms and agencies and entities that would like to use them. The API consists\nof a core header file defining required \nC\n functions. It also defines a number of interfaces to other languages on top of the \nC\n API.\n\n\nThe documentation for the \nC\n API is available \nhere\n.\n\n\nThere are currently interfaces for:\n\n\nThere are plans to write interfaces for:\n\n\n\n\nC++\n\n\nPython\n\n\nC#\n\n\nJava\n\n\n\n\nAbout\n\n\nComputer vision is a rapidly expanding and improving field that has seen significant\nprogress in it's capabilities over the past decade. Government agencies can leverage\ncomputer vision algorithms to better understand images and videos that they ingest.\nThis in turn can lead to improved response times, increased public safety, and numerous\nother benefits. The JanICE API provides a common framework that commercial vendors and\ngovernment agencies can use to ease integration between algorithms and use cases. The\nAPI aims to cover a number of different Computer Vision subproblems. At this time these\nproblems include:\n\n\n\n\nFace Recognition\n\n\nCamera Identification\n\n\n\n\nSome function calls serve multiple use cases in different ways. In those cases the function documentation strives to clearly indicate the differences. If no differences are indicated it means that the function is universal in that it applies the same to each subproblem addressed by the API.\n\n\nFocus Areas\n\n\nFace Recognition\n\n\nFacial recognition has emerged as a key technology for government agencies to efficiently triage and analyze large data streams. A large ecosystem of facial recognition algorithms already exists from a variety of sources including commercial vendors, government programs and academia. However, integrating this important technology into existing technology stacks is a difficult and expensive endeavor. The JanICE API aims to address this problem by functioning as a compatibility layer between users and the algorithms. Users can write their applications on \"top\" of the API while algorithm providers will implement their algorithms \"beneath\" the API. This means that users can write their applications independent of any single FR algorithm and gives them the freedom to select the algorithm or algorithms that best serve their specific use case without worrying about integration. Algorithm providers will be able to serve their algorithms across teams and agencies without having to integrate with the different tools and services of each specific team.\n\n\nCamera Identification\n\n\nCamera identification provides the capability to use sensor pattern noise (SPN) to identify images (still and video) that have been captured using the same source camera device. Since the SPN generation and matching processes are similar to biometric template generation and matching, the JanICE functionality can be adapted for this purpose. Likewise the use cases are similar in that 1:1, 1:N, and clustering capabilities are needed. (The latter two implying the existence of a gallery of imagery for which SPN has been calculated.) This also allows both FR and Camera Identification modules (algorithms) to be deployed within the same application/platform.\n\n\nLicense\n\n\nThe API is provided under the MIT license(LICENSE.txt) and is\n\nfree for academic and commercial use\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/#janice-api", 
            "text": "The JanICE API is a  C  API that provides a common interface between computer vision\nalgorithms and agencies and entities that would like to use them. The API consists\nof a core header file defining required  C  functions. It also defines a number of interfaces to other languages on top of the  C  API.  The documentation for the  C  API is available  here .  There are currently interfaces for:  There are plans to write interfaces for:   C++  Python  C#  Java", 
            "title": "JanICE API"
        }, 
        {
            "location": "/#about", 
            "text": "Computer vision is a rapidly expanding and improving field that has seen significant\nprogress in it's capabilities over the past decade. Government agencies can leverage\ncomputer vision algorithms to better understand images and videos that they ingest.\nThis in turn can lead to improved response times, increased public safety, and numerous\nother benefits. The JanICE API provides a common framework that commercial vendors and\ngovernment agencies can use to ease integration between algorithms and use cases. The\nAPI aims to cover a number of different Computer Vision subproblems. At this time these\nproblems include:   Face Recognition  Camera Identification   Some function calls serve multiple use cases in different ways. In those cases the function documentation strives to clearly indicate the differences. If no differences are indicated it means that the function is universal in that it applies the same to each subproblem addressed by the API.", 
            "title": "About"
        }, 
        {
            "location": "/#focus-areas", 
            "text": "", 
            "title": "Focus Areas"
        }, 
        {
            "location": "/#face-recognition", 
            "text": "Facial recognition has emerged as a key technology for government agencies to efficiently triage and analyze large data streams. A large ecosystem of facial recognition algorithms already exists from a variety of sources including commercial vendors, government programs and academia. However, integrating this important technology into existing technology stacks is a difficult and expensive endeavor. The JanICE API aims to address this problem by functioning as a compatibility layer between users and the algorithms. Users can write their applications on \"top\" of the API while algorithm providers will implement their algorithms \"beneath\" the API. This means that users can write their applications independent of any single FR algorithm and gives them the freedom to select the algorithm or algorithms that best serve their specific use case without worrying about integration. Algorithm providers will be able to serve their algorithms across teams and agencies without having to integrate with the different tools and services of each specific team.", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/#camera-identification", 
            "text": "Camera identification provides the capability to use sensor pattern noise (SPN) to identify images (still and video) that have been captured using the same source camera device. Since the SPN generation and matching processes are similar to biometric template generation and matching, the JanICE functionality can be adapted for this purpose. Likewise the use cases are similar in that 1:1, 1:N, and clustering capabilities are needed. (The latter two implying the existence of a gallery of imagery for which SPN has been calculated.) This also allows both FR and Camera Identification modules (algorithms) to be deployed within the same application/platform.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/#license", 
            "text": "The API is provided under the MIT license(LICENSE.txt) and is free for academic and commercial use .", 
            "title": "License"
        }, 
        {
            "location": "/api/cv_concepts/", 
            "text": "Objects\n\n\nThis API is built around opaque object pointers that represent high-level\ncomputer vision concepts. To provide the most flexibility to implementors\nof this API these objects are not defined in the API and should instead\nbe defined in the implementation. Access to these object is regulated\nthrough defined accessor functions that implementors are either required\nor optional as indicated in their documentation below.\n\n\nMedia\n\n\nThis API seeks to define a common representation for both images and videos,\nwhich we call media. Implementors of this API are free to define media however\nthey like using the \nJaniceMediaType\n structure. However, it is\nstrongly recommended that the implementation is lazy when loading videos into\nmemory. It is expected that this API will load multiple videos at once for\nprocessing, for example during a call to\n\njanice_cluster_media\n, which can overload system memory\nif all frames are loaded at once. An example implementation has been provided\n\nhere\n that uses the popular OpenCV\nlibrary.\n\n\nDetection\n\n\nIn the context of this API, detection is used to refer to the identification of\nobjects of interest within a \nmedia\n object. Detections are represented\nusing the \nJaniceDetectionType\n object which implementors\nare free to define however they would like. For images, a detection is defined\nas a rectangle that bounds an object of interest and an associated confidence\nvalue. For video, a single object can exist in multiple frames. A rectangle and\nconfidence are only relevant in a single frame. In this case, we define a\ndetection as a list of (rectangle, confidence) pairs that track a single object\nthrough a video. It is not required that this list be dense however (i.e.\nframes can be skipped). To support this, we extend our representation of a\ndetection to a (rectangle,confidence,frame) tuple where frame gives the index\nof the frame the rectangle was found in.\n\n\nFeature Extraction\n\n\nThis API defines feature extraction as the process of turning 1 or more\n\ndetections\n that refer to the same object into a single\nrepresentation. This representation is defined in the API using the\n[JaniceTemplateType(#JaniceTemplateType) object. In some cases (e.g. face\nrecognition) this model of [multiple detections] -\n [single representation]\ncontradicts the current paradigm of [single detection] -\n [single\nrepresentation]. Implementors are free to implement whatever paradigm they\nchoose internally (i.e. a JanICE template could be a simple list of single\ndetection templates) provided the \ncomparison\n functions work\nappropriately.\n\n\nGalleries\n\n\nThis API defines a gallery object that represents a collection of templates.\nGalleries are useful in the 1-N use case (see\n\nthe section on comparison\n) when a user would like to query an\nunknown probe template against a set of known identities. A naive\nimplementation of a gallery might be a simple array of templates. Often\nhowever, implementations have optimized algorithms or data structures that can\nlead to more efficient search times. It is recommended that advanced data\nstructures be implemented as part of a gallery. Please note however the rules\non gallery modification:\n\n\n\n\nGallery objects may be modified (templates inserted or removed) at any time.\n\n\nIt is understood that some preprocessing might need to be done between\n   gallery modification and efficient search. A function\n   \njanice_prepare_gallery\n exists for this\n   purpose. The calling of this function however is optional. Please see the\n   \ndocumentation\n for more information.\n\n\n\n\nComparison\n\n\nThis API defines two possible types of comparisons, 1-1 and 1-many or 1-N.\nThese are represented by the \njanice_verify\n and\n\njanice_search\n functions respectively. The API\nquantified the relationship between two templates as a single number called a\nsimilarity score. The definition of a similarity score in the context of this\nAPI is discussed \nhere\n.\n\n\nClustering\n\n\nThis API defines clustering is the automatic and unsupervised combination of unlabelled templates into groups of like templates. What constitutes\nlikeness is heavily dependent on the use case and context in question. One\nexample when dealing with faces is grouping based on identity, where all faces\nbelonging to a single individual are placed in a cluster.", 
            "title": "Computer Vision Concepts"
        }, 
        {
            "location": "/api/cv_concepts/#Objects", 
            "text": "This API is built around opaque object pointers that represent high-level\ncomputer vision concepts. To provide the most flexibility to implementors\nof this API these objects are not defined in the API and should instead\nbe defined in the implementation. Access to these object is regulated\nthrough defined accessor functions that implementors are either required\nor optional as indicated in their documentation below.", 
            "title": "Objects"
        }, 
        {
            "location": "/api/cv_concepts/#Media", 
            "text": "This API seeks to define a common representation for both images and videos,\nwhich we call media. Implementors of this API are free to define media however\nthey like using the  JaniceMediaType  structure. However, it is\nstrongly recommended that the implementation is lazy when loading videos into\nmemory. It is expected that this API will load multiple videos at once for\nprocessing, for example during a call to janice_cluster_media , which can overload system memory\nif all frames are loaded at once. An example implementation has been provided here  that uses the popular OpenCV\nlibrary.", 
            "title": "Media"
        }, 
        {
            "location": "/api/cv_concepts/#Detection", 
            "text": "In the context of this API, detection is used to refer to the identification of\nobjects of interest within a  media  object. Detections are represented\nusing the  JaniceDetectionType  object which implementors\nare free to define however they would like. For images, a detection is defined\nas a rectangle that bounds an object of interest and an associated confidence\nvalue. For video, a single object can exist in multiple frames. A rectangle and\nconfidence are only relevant in a single frame. In this case, we define a\ndetection as a list of (rectangle, confidence) pairs that track a single object\nthrough a video. It is not required that this list be dense however (i.e.\nframes can be skipped). To support this, we extend our representation of a\ndetection to a (rectangle,confidence,frame) tuple where frame gives the index\nof the frame the rectangle was found in.", 
            "title": "Detection"
        }, 
        {
            "location": "/api/cv_concepts/#FeatureExtraction", 
            "text": "This API defines feature extraction as the process of turning 1 or more detections  that refer to the same object into a single\nrepresentation. This representation is defined in the API using the\n[JaniceTemplateType(#JaniceTemplateType) object. In some cases (e.g. face\nrecognition) this model of [multiple detections] -  [single representation]\ncontradicts the current paradigm of [single detection] -  [single\nrepresentation]. Implementors are free to implement whatever paradigm they\nchoose internally (i.e. a JanICE template could be a simple list of single\ndetection templates) provided the  comparison  functions work\nappropriately.", 
            "title": "Feature Extraction"
        }, 
        {
            "location": "/api/cv_concepts/#Galleries", 
            "text": "This API defines a gallery object that represents a collection of templates.\nGalleries are useful in the 1-N use case (see the section on comparison ) when a user would like to query an\nunknown probe template against a set of known identities. A naive\nimplementation of a gallery might be a simple array of templates. Often\nhowever, implementations have optimized algorithms or data structures that can\nlead to more efficient search times. It is recommended that advanced data\nstructures be implemented as part of a gallery. Please note however the rules\non gallery modification:   Gallery objects may be modified (templates inserted or removed) at any time.  It is understood that some preprocessing might need to be done between\n   gallery modification and efficient search. A function\n    janice_prepare_gallery  exists for this\n   purpose. The calling of this function however is optional. Please see the\n    documentation  for more information.", 
            "title": "Galleries"
        }, 
        {
            "location": "/api/cv_concepts/#Comparison", 
            "text": "This API defines two possible types of comparisons, 1-1 and 1-many or 1-N.\nThese are represented by the  janice_verify  and janice_search  functions respectively. The API\nquantified the relationship between two templates as a single number called a\nsimilarity score. The definition of a similarity score in the context of this\nAPI is discussed  here .", 
            "title": "Comparison"
        }, 
        {
            "location": "/api/cv_concepts/#Clustering", 
            "text": "This API defines clustering is the automatic and unsupervised combination of unlabelled templates into groups of like templates. What constitutes\nlikeness is heavily dependent on the use case and context in question. One\nexample when dealing with faces is grouping based on identity, where all faces\nbelonging to a single individual are placed in a cluster.", 
            "title": "Clustering"
        }, 
        {
            "location": "/api/software_concepts/", 
            "text": "Error Handling\n\n\nThe API handles errors using return codes. Valid return codes are defined\n\nhere\n. In general, it is assumed that new memory is only\nallocated if a function returns \nJANICE_SUCCESS\n. Therefore,\n\nimplementors are REQUIRED to deallocate any memory allocated during a\nfunction call if that function returns an error.\n\n\nMemory Allocation\n\n\nThe API tries to be agnostic to different memory allocation strategies and\nmemory allocators for all API objects. For convenience and brevity however,\nfunctions that return arrays of values (for example\n\njanice_search\n) must allocate those arrays using the\n\nmalloc\n\nfunction available in the C standard library. It is the responsibility of the\nuser of the API to ensure that those arrays are deleted with corresponding\ncalls to\n\nfree\n.\n\n\nIn general, the API often passes unallocated pointers to functions for the\nimplementor to allocate appropriately. This is indicated if the type of a\nfunction input is \nJaniceObject**\n, or in the case of a utility\n\ntypedef\n \nJaniceTypedef*\n. It is considered a best\npractice for unallocated pointers to be initialized to \nNULL\n before\nthey are passed to a function, but this is not guaranteed. It is the\nresponsibility of the users of the API to ensure that pointers do not point to\nvalid data before they are passed to functions in which they are modified, as\nthis would cause memory leaks.\n\n\nThread Safety\n\n\nAll functions are marked one of:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nThread safe\n\n\nCan be called simultaneously from multiple threads, even when the invocations use shared data.\n\n\n\n\n\n\nReentrant\n\n\nCan be called simultaneously from multiple threads, but only if each invocation uses its own data.\n\n\n\n\n\n\nThread unsafe\n\n\nCan not be called simultaneously from multiple threads.\n\n\n\n\n\n\n\n\nCompiling\n\n\nDefine \nJANICE_LIBRARY\n during compilation to export JanICE symbols.\n\n\nVersioning\n\n\nThis API follows the \nsemantic versioning\n paradigm. Each\nreleased iteration is tagged with a major.minor.patch version. A change in\nthe major version indicates a breaking change. A change in the minor version\nindicates a backwards-compatible change. A change in the patch version\nindicates a backwards-compatible bug fix.", 
            "title": "Software Concepts"
        }, 
        {
            "location": "/api/software_concepts/#ErrorHandling", 
            "text": "The API handles errors using return codes. Valid return codes are defined here . In general, it is assumed that new memory is only\nallocated if a function returns  JANICE_SUCCESS . Therefore, implementors are REQUIRED to deallocate any memory allocated during a\nfunction call if that function returns an error.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/api/software_concepts/#MemoryAllocation", 
            "text": "The API tries to be agnostic to different memory allocation strategies and\nmemory allocators for all API objects. For convenience and brevity however,\nfunctions that return arrays of values (for example janice_search ) must allocate those arrays using the malloc \nfunction available in the C standard library. It is the responsibility of the\nuser of the API to ensure that those arrays are deleted with corresponding\ncalls to free .  In general, the API often passes unallocated pointers to functions for the\nimplementor to allocate appropriately. This is indicated if the type of a\nfunction input is  JaniceObject** , or in the case of a utility typedef   JaniceTypedef* . It is considered a best\npractice for unallocated pointers to be initialized to  NULL  before\nthey are passed to a function, but this is not guaranteed. It is the\nresponsibility of the users of the API to ensure that pointers do not point to\nvalid data before they are passed to functions in which they are modified, as\nthis would cause memory leaks.", 
            "title": "Memory Allocation"
        }, 
        {
            "location": "/api/software_concepts/#ThreadSafety", 
            "text": "All functions are marked one of:     Type  Description      Thread safe  Can be called simultaneously from multiple threads, even when the invocations use shared data.    Reentrant  Can be called simultaneously from multiple threads, but only if each invocation uses its own data.    Thread unsafe  Can not be called simultaneously from multiple threads.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/software_concepts/#Compiling", 
            "text": "Define  JANICE_LIBRARY  during compilation to export JanICE symbols.", 
            "title": "Compiling"
        }, 
        {
            "location": "/api/software_concepts/#Versioning", 
            "text": "This API follows the  semantic versioning  paradigm. Each\nreleased iteration is tagged with a major.minor.patch version. A change in\nthe major version indicates a breaking change. A change in the minor version\nindicates a backwards-compatible change. A change in the patch version\nindicates a backwards-compatible bug fix.", 
            "title": "Versioning"
        }, 
        {
            "location": "/api/enums/", 
            "text": "JaniceError\n\n\nEvery function in the JanICE \nC\n API returns an error code when executed. In the case of successful application \nJANICE_SUCCESS\n is returned, otherwise a code indicating the specific issue is returned. The error codes are:\n\n\n\n\n\n\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nJANICE_SUCCESS\n\n\nNo error\n\n\n\n\n\n\nJANICE_UNKNOWN_ERROR\n\n\nCatch all error code\n\n\n\n\n\n\nJANICE_OUT_OF_MEMORY\n\n\nOut of memory error\n\n\n\n\n\n\nJANICE_INVALID_SDK_PATH\n\n\nInvalid SDK location\n\n\n\n\n\n\nJANICE_BAD_SDK_CONFIG\n\n\nInvalid SDK configuration\n\n\n\n\n\n\nJANICE_BAD_LICENSE\n\n\nIncorrect license file\n\n\n\n\n\n\nJANICE_MISSING_DATA\n\n\nMissing SDK data\n\n\n\n\n\n\nJANICE_INVALID_GPU\n\n\nThe GPU is not functioning\n\n\n\n\n\n\nJANICE_OPEN_ERROR\n\n\nFailed to open a file\n\n\n\n\n\n\nJANICE_READ_ERROR\n\n\nFailed to read from a file\n\n\n\n\n\n\nJANICE_WRITE_ERROR\n\n\nFailed to write to a file\n\n\n\n\n\n\nJANICE_PARSE_ERROR\n\n\nFailed to parse a file\n\n\n\n\n\n\nJANICE_INVALID_MEDIA\n\n\nFailed to decode a media file\n\n\n\n\n\n\nJANICE_DUPLICATE_ID\n\n\nTemplate id already exists in a gallery\n\n\n\n\n\n\nJANICE_MISSING_ID\n\n\nTemplate id can't be found\n\n\n\n\n\n\nJANICE_MISSING_FILE_NAME\n\n\nAn expected file name is not given\n\n\n\n\n\n\nJANICE_INCORRECT_ROLE\n\n\nIncorrect template role\n\n\n\n\n\n\nJANICE_FAILURE_TO_ENROLL\n\n\nCould not construct a template\n\n\n\n\n\n\nJANICE_FAILURE_TO_SERIALIZE\n\n\nCould not serialize a data structure\n\n\n\n\n\n\nJANICE_FAILURE_TO_DESERIALIZE\n\n\nCould not deserialize a data structure\n\n\n\n\n\n\nJANICE_NOT_IMPLEMENTED\n\n\nOptional function return\n\n\n\n\n\n\nJANICE_NUM_ERRORS\n\n\nUtility to iterate over all errors\n\n\n\n\n\n\n\n\nJaniceEnrollmentType\n\n\nOften times, the templates produced by algorithms will require different data for different use cases. The enrollment type indicates what the use case for the created template will be, allowing implementors to specialize their templates if they so desire. The use cases supported by the API are:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nJanice11Reference\n\n\nThe template will be used as a reference template for 1 to 1 verification.\n\n\n\n\n\n\nJanice11Verification\n\n\nThe template will be used for verification against a reference template in 1 to 1 verification.\n\n\n\n\n\n\nJanice1NProbe\n\n\nThe template will be used as a probe in 1 to N search.\n\n\n\n\n\n\nJanice1NGallery\n\n\nThe template will be enrolled into a gallery and searched against for 1 to N search.\n\n\n\n\n\n\nJaniceCluster\n\n\nThe template will be used for clustering", 
            "title": "Enumerations"
        }, 
        {
            "location": "/api/enums/#JaniceError", 
            "text": "Every function in the JanICE  C  API returns an error code when executed. In the case of successful application  JANICE_SUCCESS  is returned, otherwise a code indicating the specific issue is returned. The error codes are:     Code  Description      JANICE_SUCCESS  No error    JANICE_UNKNOWN_ERROR  Catch all error code    JANICE_OUT_OF_MEMORY  Out of memory error    JANICE_INVALID_SDK_PATH  Invalid SDK location    JANICE_BAD_SDK_CONFIG  Invalid SDK configuration    JANICE_BAD_LICENSE  Incorrect license file    JANICE_MISSING_DATA  Missing SDK data    JANICE_INVALID_GPU  The GPU is not functioning    JANICE_OPEN_ERROR  Failed to open a file    JANICE_READ_ERROR  Failed to read from a file    JANICE_WRITE_ERROR  Failed to write to a file    JANICE_PARSE_ERROR  Failed to parse a file    JANICE_INVALID_MEDIA  Failed to decode a media file    JANICE_DUPLICATE_ID  Template id already exists in a gallery    JANICE_MISSING_ID  Template id can't be found    JANICE_MISSING_FILE_NAME  An expected file name is not given    JANICE_INCORRECT_ROLE  Incorrect template role    JANICE_FAILURE_TO_ENROLL  Could not construct a template    JANICE_FAILURE_TO_SERIALIZE  Could not serialize a data structure    JANICE_FAILURE_TO_DESERIALIZE  Could not deserialize a data structure    JANICE_NOT_IMPLEMENTED  Optional function return    JANICE_NUM_ERRORS  Utility to iterate over all errors", 
            "title": "JaniceError"
        }, 
        {
            "location": "/api/enums/#JaniceEnrollmentType", 
            "text": "Often times, the templates produced by algorithms will require different data for different use cases. The enrollment type indicates what the use case for the created template will be, allowing implementors to specialize their templates if they so desire. The use cases supported by the API are:     Type  Description      Janice11Reference  The template will be used as a reference template for 1 to 1 verification.    Janice11Verification  The template will be used for verification against a reference template in 1 to 1 verification.    Janice1NProbe  The template will be used as a probe in 1 to N search.    Janice1NGallery  The template will be enrolled into a gallery and searched against for 1 to N search.    JaniceCluster  The template will be used for clustering", 
            "title": "JaniceEnrollmentType"
        }, 
        {
            "location": "/api/objects/", 
            "text": "Overview\n\n\nJanice objects generally fall into two classes; utility objects that exist\nto simplify function parameters or represent basic classes, and fundamental\nobjects that correspond to high level API concepts. For fundamental objects,\nthe API employs the \nPIMPL idiom\n\nto abstract away the implementation from the end user. This has the added\nadvantage of not enforcing any paradigm on implementors to implement their\nfundamental objects in a predefined manner.\n\n\nJaniceMediaType\n\n\nAn opaque pointer to a struct that represents an image or video. See \nthe\nparagraph on media\n for more information. The API deals exclusively\nwith pointers to this object and provides the following typedefs for convenience\n\n\n\n\n\n\n\n\nName\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nJaniceMedia\n\n\ntypedef struct JaniceMediaType*\n\n\n\n\n\n\nJaniceConstMedia\n\n\ntypedef const struct JaniceMediaType*\n\n\n\n\n\n\n\n\nJaniceRect\n\n\nA simple struct that represents a rectangle\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx\n\n\nuint32_t\n\n\nThe x offset of the rectangle in pixels\n\n\n\n\n\n\ny\n\n\nuint32_t\n\n\nThe y offset of the rectangle in pixels\n\n\n\n\n\n\nwidth\n\n\nuint32_t\n\n\nThe width of the rectangle in pixels\n\n\n\n\n\n\nheight\n\n\nuint32_t\n\n\nThe height of the rectangle in pixels\n\n\n\n\n\n\n\n\nJaniceDetectionInstance\n\n\nA single detection in an image or video, represented as a rectangle,\nconfidence, and frame number. See \nthe paragraph on detection\n for\ninformation on why this structure is necessary.\n\n\nConfidence\n\n\nThe confidence value indicates a likelihood that the rectangle actually bounds\nan object of interest. It is \nNOT\n required to be a probability and often\nonly has meaning relative to other confidence values from the same algorithm.\nThe only restriction is that a larger confidence value indicates a greater\nlikelihood that the rectangle bounds an object.\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrect\n\n\nJaniceRect\n\n\nThe rectangle that bounds the object of interest\n\n\n\n\n\n\nconfidence\n\n\ndouble\n\n\nA likelihood that the rectangle bounds an object of interest. See \nthis description\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nA frame index indicating which frame the rectangle came from. If the rectangle comes from an image this should be set to 0\n\n\n\n\n\n\n\n\nJaniceDetectionType\n\n\nAn opaque pointer to a struct that represents a detection. See \nthe paragraph\non detection\n for more information. The API deals exclusively with\npointers to this object and provides the following typedefs for convenience.\n\n\n\n\n\n\n\n\nName\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nJaniceDetection\n\n\ntypedef struct JaniceDetectionType*\n\n\n\n\n\n\nJaniceConstDetection\n\n\ntypedef const struct JaniceDetectionType*\n\n\n\n\n\n\n\n\nJaniceTemplateType\n\n\nAn opaque pointer to a struct that represents a template. See \nthe paragraph on\nfeature extraction\n for more information. The API deals\nexclusively with pointers to this object and provides the following typedefs\nfor convienience.\n\n\n\n\n\n\n\n\nName\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nJaniceTemplate\n\n\ntypedef struct JaniceTemplateType*\n\n\n\n\n\n\nJaniceConstTemplate\n\n\ntypedef const struct JaniceTemplateType*\n\n\n\n\n\n\n\n\nJaniceGalleryType\n\n\nAn opaque pointer to a struct that represents a gallery. See \nthe paragraph on\ngalleries\n for more information. The API deals exclusively with\npointers to this object and provides the following typedefs for convenience.\n\n\n\n\n\n\n\n\nName\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nJaniceGallery\n\n\ntypedef struct JaniceGalleryType*\n\n\n\n\n\n\nJaniceConstGallery\n\n\ntypedef const struct JaniceGalleryType*\n\n\n\n\n\n\n\n\nJaniceClusterItem\n\n\nA utility structure that stores cluster information about an API object.\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncluster_id\n\n\nuint32_t\n\n\nThe id of the cluster that this item belongs to. Two items with the same cluster id are members of the same cluster\n\n\n\n\n\n\nsource_id\n\n\nuint32_t\n\n\nThe id of the source object this item refers to. Two items with the same source id came from the same source object.\n\n\n\n\n\n\nconfidence\n\n\ndouble\n\n\nThe confidence that this item belongs in it's assigned cluster. The confidence could be used after the fact to \"purify\" clusters by removing the least confident members.\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection\n\n\nIn the special case where the source object is a \nJaniceMediaType\n object, the source id is not enough to handle the case where multiple objects of interest exist within the media. The detection is used in this case to give the specific location of the object that this item refers to.", 
            "title": "Objects"
        }, 
        {
            "location": "/api/objects/#overview", 
            "text": "Janice objects generally fall into two classes; utility objects that exist\nto simplify function parameters or represent basic classes, and fundamental\nobjects that correspond to high level API concepts. For fundamental objects,\nthe API employs the  PIMPL idiom \nto abstract away the implementation from the end user. This has the added\nadvantage of not enforcing any paradigm on implementors to implement their\nfundamental objects in a predefined manner.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/objects/#JaniceMediaType", 
            "text": "An opaque pointer to a struct that represents an image or video. See  the\nparagraph on media  for more information. The API deals exclusively\nwith pointers to this object and provides the following typedefs for convenience     Name  Definition      JaniceMedia  typedef struct JaniceMediaType*    JaniceConstMedia  typedef const struct JaniceMediaType*", 
            "title": "JaniceMediaType"
        }, 
        {
            "location": "/api/objects/#JaniceRect", 
            "text": "A simple struct that represents a rectangle", 
            "title": "JaniceRect"
        }, 
        {
            "location": "/api/objects/#JaniceRectFields", 
            "text": "Name  Type  Description      x  uint32_t  The x offset of the rectangle in pixels    y  uint32_t  The y offset of the rectangle in pixels    width  uint32_t  The width of the rectangle in pixels    height  uint32_t  The height of the rectangle in pixels", 
            "title": "Fields"
        }, 
        {
            "location": "/api/objects/#JaniceDetectionInstance", 
            "text": "A single detection in an image or video, represented as a rectangle,\nconfidence, and frame number. See  the paragraph on detection  for\ninformation on why this structure is necessary.", 
            "title": "JaniceDetectionInstance"
        }, 
        {
            "location": "/api/objects/#JaniceDetectionInstanceConfidence", 
            "text": "The confidence value indicates a likelihood that the rectangle actually bounds\nan object of interest. It is  NOT  required to be a probability and often\nonly has meaning relative to other confidence values from the same algorithm.\nThe only restriction is that a larger confidence value indicates a greater\nlikelihood that the rectangle bounds an object.", 
            "title": "Confidence"
        }, 
        {
            "location": "/api/objects/#JaniceDetectionInstanceFields", 
            "text": "Name  Type  Description      rect  JaniceRect  The rectangle that bounds the object of interest    confidence  double  A likelihood that the rectangle bounds an object of interest. See  this description    frame  uint32_t  A frame index indicating which frame the rectangle came from. If the rectangle comes from an image this should be set to 0", 
            "title": "Fields"
        }, 
        {
            "location": "/api/objects/#JaniceDetectionType", 
            "text": "An opaque pointer to a struct that represents a detection. See  the paragraph\non detection  for more information. The API deals exclusively with\npointers to this object and provides the following typedefs for convenience.     Name  Definition      JaniceDetection  typedef struct JaniceDetectionType*    JaniceConstDetection  typedef const struct JaniceDetectionType*", 
            "title": "JaniceDetectionType"
        }, 
        {
            "location": "/api/objects/#JaniceTemplateType", 
            "text": "An opaque pointer to a struct that represents a template. See  the paragraph on\nfeature extraction  for more information. The API deals\nexclusively with pointers to this object and provides the following typedefs\nfor convienience.     Name  Definition      JaniceTemplate  typedef struct JaniceTemplateType*    JaniceConstTemplate  typedef const struct JaniceTemplateType*", 
            "title": "JaniceTemplateType"
        }, 
        {
            "location": "/api/objects/#JaniceGalleryType", 
            "text": "An opaque pointer to a struct that represents a gallery. See  the paragraph on\ngalleries  for more information. The API deals exclusively with\npointers to this object and provides the following typedefs for convenience.     Name  Definition      JaniceGallery  typedef struct JaniceGalleryType*    JaniceConstGallery  typedef const struct JaniceGalleryType*", 
            "title": "JaniceGalleryType"
        }, 
        {
            "location": "/api/objects/#JaniceClusterItem", 
            "text": "A utility structure that stores cluster information about an API object.", 
            "title": "JaniceClusterItem"
        }, 
        {
            "location": "/api/objects/#fields", 
            "text": "Name  Type  Description      cluster_id  uint32_t  The id of the cluster that this item belongs to. Two items with the same cluster id are members of the same cluster    source_id  uint32_t  The id of the source object this item refers to. Two items with the same source id came from the same source object.    confidence  double  The confidence that this item belongs in it's assigned cluster. The confidence could be used after the fact to \"purify\" clusters by removing the least confident members.    detection  JaniceDetection  In the special case where the source object is a  JaniceMediaType  object, the source id is not enough to handle the case where multiple objects of interest exist within the media. The detection is used in this case to give the specific location of the object that this item refers to.", 
            "title": "Fields"
        }, 
        {
            "location": "/api/functions/", 
            "text": "Overview\n\n\nThere are a number of use cases associated with this API. The meaning of the\nconcepts this API tries to convey changes depending on the use case. In the\nfollowing documentation, if the use of the function changes depending on the\nuse case, the description will clearly state what the use is for each relevant\nuse case. If the use of the function does not change, a single description will\nbe provided.\n\n\nAll API functions return an \nerror code\n. Because it is universal\nthe return type is not stated in the following documentation.\n\n\njanice_initialize\n\n\nInitialize global or shared state for the implementation. This function should\nbe called once at the start of the application, before making any other calls\nto the API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_initialize(const char* sdk_path,\n                                            const char* temp_path,\n                                            const char* algorithm,\n                                            const int gpu_dev);\n\n\n\n\nThread Safety\n\n\nThis function is thread unsafe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsdk_path\n\n\nconst char*\n\n\nPath to a \nread-only\n directory containing the JanICE compliant SDK as specified by the implementor\n\n\n\n\n\n\ntemp_path\n\n\nconst char*\n\n\nPath to an existing empty \nread-write\n directory for use as temporary file storage by the implementation. This path must be guaranteed until \njanice_finalize\n.\n\n\n\n\n\n\nalgorithm\n\n\nconst char*\n\n\nAn empty string indicating the a default algorithm, or an implementation defined string containing an alternative configuration\n\n\n\n\n\n\ngpu_dev\n\n\nint\n\n\nAn index indicated a GPU device to use. If no GPU is available users should pass -1. If implementors do not offer a GPU solution they can ignore this value.\n\n\n\n\n\n\n\n\njanice_train\n\n\nTrain an implementation using new data.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_train(const char* data_prefix,\n                                       const char* data_list);\n\n\n\n\nThread Safety\n\n\nThis function is thread unsafe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata_prefix\n\n\nconst char*\n\n\nA prefix path pointing to the location of training data\n\n\n\n\n\n\ndata_train\n\n\nconst char*\n\n\nA list of training data and labels. The format is currently unspecified\n\n\n\n\n\n\n\n\nNotes\n\n\nThis function is untested, unstable and most likely subject to breaking changes\nin future releases.\n\n\njanice_error_to_string\n\n\nConvert an \nerror code\n into a string for printing.\n\n\nSignature\n\n\nJANICE_EXPORT const char* janice_error_to_string(JaniceError error);\n\n\n\n\nThread Safety\n\n\nThis function is thread safe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nerror\n\n\nJaniceError\n\n\nAn error code\n\n\n\n\n\n\n\n\nReturn Value\n\n\nThis is the only function in the API that does not return\n\nJaniceError\n. It returns \nconst char*\n which is a\nnull-terminated list of characters that describe the input error.\n\n\njanice_sdk_version\n\n\nQuery the implementation for the version of the API it was designed to\nimplement. See \nthe section on software versioning\n for more\ninformation on the versioning process for this API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_sdk_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);\n\n\n\n\nThread Safety\n\n\nThis function is thread safe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmajor\n\n\nuint32_t*\n\n\nThe supported major version of the API\n\n\n\n\n\n\nminor\n\n\nuint32_t*\n\n\nThe supported minor version of the API\n\n\n\n\n\n\npatch\n\n\nuint32_t*\n\n\nThe supported patch version of the API\n\n\n\n\n\n\n\n\njanice_create_media\n\n\nCreate a \nJaniceMediaType\n object from a file.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_media(const char* filename,\n                                              JaniceMedia* media);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nA path to an image or video on disk\n\n\n\n\n\n\nmedia\n\n\nJaniceMedia*\n\n\nAn uninitialized pointer to a media object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media = NULL;\nif (janice_create_media(\nexample.media\n, \nmedia) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_media\n\n\nFree any memory associated with a \nJaniceMediaType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_media(JaniceMedia* media);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceMedia*\n\n\nA media object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media; // Where media is a valid media object created previously\nif (janice_free_media(\nmedia) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_create_detection\n\n\nCreate a detection from a known rectangle. This is useful if a human has\nindentified an object of interest and would like to run subsequent API\nfunctions on it. In the case where the input media is a video the given\nrectangle is considered an initial sighting of the object of interest. The\nimplementation may detect additional sightings of the object in successive\nframes.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_detection(JaniceConstMedia media,\n                                                  const JaniceRect rect,\n                                                  uint32_t frame,\n                                                  JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nFace Recognition\n\n\nThe provided rectangle will encapsulate a face in the media.\n\n\nCamera Identification\n\n\nThe provided rectangle will encapsulate a region of interest in the media. Often the\nrectangle will simply border the entire image. Note that at this time camera\nidentification is only implemented for images and will return an error if the\nmedia is a video. Because the implementation is image-only the value in the\nframe parameter is ignored.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceConstMedia\n\n\nA media object to create the detection from\n\n\n\n\n\n\nrect\n\n\nconst \nJaniceRect\n\n\nA rectangle that bounds the object of interest\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nAn index to the frame in the media the rectangle refers to. If the media is an image this should be 0.\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized pointer to a detection object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media; // Where media is a valid media object created previously\n\nJaniceRect rect; // Create a bounding rectangle around an object of interest\nrect.x      = 10; // The rectangle should fall within the bounds of the media\nrect.y      = 10; // This code assumes media width \n 110 and media height \n 110\nrect.width  = 100;\nrect.height = 100;\n\nJaniceDetection detection = NULL; // best practice to initialize to NULL\nif (janice_create_detection(media, rect, 0 /* frame */, \ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_detect\n\n\nAutomatically detect objects in a media object. See \nthe paragraph on\ndetection\n for an overview of detection in the context of this API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_detect(JaniceConstMedia media,\n                                        uint32_t min_object_size,\n                                        JaniceDetection* detections,\n                                        uint32_t* num_detections);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nMinimum Object Size\n\n\nThis function specifies a minimum object size as one of its parameters. This\nvalue indicates the minimum size of objects that the user would like to see\ndetected. Often, increasing the minimum size can improve runtime of algorithms.\nThe size is in pixels and corresponds to the length of the smaller side of the\nrectangle. This means a detection will be returned if and only if its smaller\nside is larger than the value specified. If the user does not wish to specify a\nminimum width 0 can be provided.\n\n\nFace Recogntion\n\n\nThis function detects faces in the media.\n\n\nCamera Identification\n\n\nThis function provides a list of size 1 where the only entry is a detection\nwith a rect that encapsulates the entire image.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceConstMedia\n\n\nA media object to create the detection from.\n\n\n\n\n\n\nmin_object_size\n\n\nuint32_t\n\n\nA minimum object size. See \nMinimum Object Size\n\n\n\n\n\n\ndetections\n\n\nJaniceDetection*\n\n\nAn uninitialized array to hold all of the detections detected in the media object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\nnum_detections\n\n\nuint32_t*\n\n\nThe number of detections detected\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media; // Where media is a valid media object created previously\nconst uint32_t min_object_size = 24; // Only find objects where the smaller\n                                     // side is \n 24 pixels\nJaniceDetection* detections = NULL; // best practice to initialize to NULL\nuint32_t num_detections; // Will be populated with the size of detections\n\nif (janice_detect(media, min_object_size, \ndetections, \nnum_detections) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_detection_get_instances\n\n\nGet a list of the \nJaniceDetectionInstances\n that\ncomprise the detection.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_detection_get_instances(JaniceConstDetection detection,\n                                                         JaniceDetectionInstance** instances,\n                                                         uint32_t* num_instances);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nA detection object to get instances from\n\n\n\n\n\n\ninstances\n\n\nJaniceDetectionInstance**\n\n\nAn uninitialized array to hold the instances that comprise the detection. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\nnum_instances\n\n\nuint32_t*\n\n\nThe number of instances that comprise the detection\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nJaniceDetectionInstance* instances = NULL; // best practice to intialize to NULL\nuint32_t num_instances; // Will be populated with the size of instances\n\nif (janice_detection_get_instances(detection, \ninstances, \nnum_instances) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_serialize_detection\n\n\nSerialize a \nJaniceDetection\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_detection(JaniceConstDetection detection,\n                                                     unsigned char** data,\n                                                     size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nA detection object to serialize\n\n\n\n\n\n\ndata\n\n\nunsigned char**\n\n\nAn uninitialized buffer to hold the flattened data. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_detection\n\n\nDeserialize a \nJaniceDetection\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_detection(const unsigned char* data,\n                                                       size_t len,\n                                                       JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst unsigned char*\n\n\nA buffer containing data from a flattened detection object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized detection object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.detection\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);\n\n\n\n\njanice_read_detection\n\n\nRead a detection from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.detection\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_detection(const char* filename,\n                                                JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized detection object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection = NULL;\nif (janice_read_detection(\nexample.detection\n, \ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_detection\n\n\nWrite a detection to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.detection\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_detection(JaniceConstDetection detection,\n                                                 const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nThe detection object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously\nif (janice_write_detection(detection, \nexample.detection\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_detection\n\n\nFree any memory associated with a \nJaniceDetectionType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_detection(JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nA detection object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nif (janice_free_detection(\ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_create_template\n\n\nCreate a \nJaniceTemplate\n object from an array of detections.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_template(JaniceConstDetection* detections,\n                                                 uint32_t num_detections,\n                                                 JaniceEnrollmentType role,\n                                                 JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetections\n\n\nJaniceConstDetection*\n\n\nAn array of detection objects\n\n\n\n\n\n\nnum_detections\n\n\nuint32_t\n\n\nThe number of input detections\n\n\n\n\n\n\nrole\n\n\nJaniceEnrollmentType\n\n\nThe use case for the template\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection* detections; // Where detections is a valid array of valid\n                             // detection objects created previously\nconst uint32_t num_detections = K; // Where K is the number of detections in\n                                   // the detections array\nJaniceEnrollmentType role = Janice1NProbe; // This template will be used as a\n                                           // probe in 1-N search\nJaniceTemplate tmpl = NULL; // Best practice to initialize to NULL\n\nif (janice_create_template(detections, num_detections, rolw, \ntmpl) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_serialize_template\n\n\nSerialize a \nJaniceTemplate\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_template(JaniceConstTemplate tmpl,\n                                                    unsigned char** data,\n                                                    size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nA template object to serialize\n\n\n\n\n\n\ndata\n\n\nunsigned char**\n\n\nAn uninitialized buffer to hold the flattened data. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_template\n\n\nDeserialize a \nJaniceTemplate\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_template(const unsigned char** data,\n                                                      size_t len,\n                                                      JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst unsigned char*\n\n\nA buffer containing data from a flattened template object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.template\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = NULL; // best practice to initialize to NULL\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);\n\n\n\n\njanice_read_template\n\n\nRead a template from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.template\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = nullptr;\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_template(const char* filename,\n                                               JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl = NULL;\nif (janice_read_template(\nexample.template\n, \ntmpl) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_template\n\n\nWrite a template to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.template\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_template(JaniceConstTemplate tmpl,\n                                                const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nThe template object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously\nif (janice_write_template(tmpl, \nexample.template\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_template\n\n\nFree any memory associated with a \nJaniceTemplateType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_template(JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nA template object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created previously\nif (janice_free_template(\ntmpl) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_verify\n\n\nCompare two templates with the difference expressed as a similarity score.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_verify(JaniceConstTemplate reference,\n                                        JaniceConstTemplate verification,\n                                        double* similarity);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nSimilarity Score\n\n\nThis API expects that the comparison of two templates results in a single value\nthat quantifies the similarity between them. A similarity score is constrained\nby the following requirements:\n\n\n1. Higher scores indicate greater similarity\n2. Scores can be asymmetric. This mean verify(a, b) does not necessarily\n   equal verify(b, a)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreference\n\n\nJaniceConstTemplate\n\n\nA reference template. This template was created with the \nJanice11Reference\n role.\n\n\n\n\n\n\nverification\n\n\nJaniceConstTemplate\n\n\nA verification template. This template was created with the \nJanice11Verification\n role.\n\n\n\n\n\n\nsimilarity\n\n\ndouble*\n\n\nA similarity score. See \nthis section\n for more information.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate reference; // Where reference is a valid template object created\n                          // previously\nJaniceTemplate verification; // Where verification is a valid template object\n                             // created previously\ndouble similarity;\nif (janice_verify(reference, verification, \nsimilarity) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_create_gallery\n\n\nCreate a \nJaniceGalleryType\n object from a list of\ntemplates and unique ids.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_gallery(JaniceConstTemplate* tmpls,\n                                                const uint32_t* ids,\n                                                JaniceGallery* gallery);\n\n\n\n\nThread Safety {: #JaniceCreateGalleryThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpls\n\n\nJaniceConstTemplate*\n\n\nAn array of templates to add to the gallery\n\n\n\n\n\n\nids\n\n\nconst uint32_t*\n\n\nA set of unique identifiers to associate with the input templates. The \nith\n id corresponds to the \nith\n input template.\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nuint32_t* ids; // Where ids is a valid array of unique unsigned integers that\n               // is the same length as tmpls\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_insert\n\n\nInsert a template into a gallery object. The template data should be copied\ninto the gallery as the template may be deleted after this function.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_insert(JaniceGallery gallery,\n                                                JaniceConstTemplate tmpl,\n                                                uint32_t id);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to insert the template into.\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nA template object to insert into the gallery.\n\n\n\n\n\n\nid\n\n\nuint32_t\n\n\nA unique id to associate with the input template\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nuint32_t id; // Where id is a unique integer to associate with tmpl. This\n             // integer should not exist in the gallery\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\n\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_remove\n\n\nRemove a template from a gallery object using its unique id.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_remove(JaniceGallery gallery,\n                                                uint32_t id);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to remove the template from\n\n\n\n\n\n\nid\n\n\nuint32_t\n\n\nA unique id associated with a template in the gallery that indicates which template should be remove.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nconst uint32_t id = 0; // A unique integer id to associate with tmpl.\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously that does not have a template with id '0'\n                       // already inserted in it.\n\n// Insert the template with id 0\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n// Now we can remove the template\nif (janice_gallery_remove(gallery, id) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_prepare\n\n\nPrepare a gallery for search. Implementors can use this function as an\nopportunity to streamline gallery objects to accelerate the search process. The\ncalling convention for this function is \nNOT\n specified by the API, this\nmeans that this function is not guaranteed to be called before\n\njanice_search\n. It also means that templates can be added\nto a gallery before and after this function is called. Implementations should\nhandle all of these calling conventions. However, users should be aware that\nthis function may be computationally expensive. They should strive to call it\nonly at critical junctions before search and as few times as possible overall.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_prepare(JaniceGallery gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to prepare\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nuint32_t* ids; // Where ids is a valid array of unique unsigned integers that\n               // is the same length as tmpls\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nuint32_t id; // Where id is a unique integer id to associate with tmpl.\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// It is valid to run search without calling prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare can be called after search\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// Search can be called again right after prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Insert another template into the gallery. This is valid after the gallery\n// has been prepared\nif (janice_gallery_insert(gallery, tmpl, 112) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare the gallery again\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_serialize_gallery\n\n\nSerialize a \nJaniceGallery\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_gallery(JaniceConstGallery gallery,\n                                                   unsigned char** data,\n                                                   size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nA gallery object to serialize\n\n\n\n\n\n\ndata\n\n\nunsigned char**\n\n\nAn uninitialized buffer to hold the flattened data. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created\n                       // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_gallery\n\n\nDeserialize a \nJaniceGallery\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_gallery(const unsigned char** data,\n                                                     size_t len,\n                                                     JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst unsigned char*\n\n\nA buffer containing data from a flattened gallery object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.gallery\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);\n\n\n\n\njanice_read_gallery\n\n\nRead a gallery from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.gallery\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_gallery(const char* filename,\n                                              JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object. See \nthe section on memory allocation\n for requirements for initialization.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery = NULL;\nif (janice_read_gallery(\nexample.gallery\n, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_gallery\n\n\nWrite a gallery to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.gallery\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_gallery(JaniceConstGallery gallery,\n                                               const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nThe gallery object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created previously\nif (janice_write_gallery(gallery, \nexample.gallery\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_gallery\n\n\nFree any memory associated with a \nJaniceGalleryType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_gallery(JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nA gallery object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created previously\nif (janice_free_gallery(\ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_search\n\n\nCompute 1-N search results between a query template object and a target gallery\nobject. The function allocates two arrays of equal size, one containing\n\nsimilarity scores\n and the other containing the\nunique id of the template the score was computed with (along with the query).\nOften it is desirable (and perhaps computationally efficient) to only see the\ntop K scores out of N possible templates. The option to set a K is provided to\nthe user as part of the function parameters.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_search(JaniceConstTemplate probe,\n                                        JaniceConstGallery gallery,\n                                        uint32_t num_requested,\n                                        double** similarities,\n                                        uint32_t** ids,\n                                        uint32_t* num_returned);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprobe\n\n\nJaniceConstTemplate\n\n\nA template object to use as a query\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nA gallery object to search against\n\n\n\n\n\n\nnum_requested\n\n\nuint32_t\n\n\nThe number of requested returns. If the user would like as many returns as there are templates in the gallery they can pass this parameter with the value 0.\n\n\n\n\n\n\nsimilarities\n\n\ndouble**\n\n\nAn array of \nsimilarity scores\n. The scores are expected to be sorted in descending order (i.e. the highest scores is stored at index 0).\n\n\n\n\n\n\nids\n\n\nuint32_t**\n\n\nAn array of unique ids identifying the target templates associated with the similarity scores. This array must be the same size as the similarities array. The \nith\n id corresponds with the \nith\n similarity.\n\n\n\n\n\n\nnum_returned\n\n\nuint32_t*\n\n\nThe number of elements in the similarities and ids arrays. This number can be different from \nnum_requested\n.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate probe;  // Where probe is a valid template object created\n                       // previously\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\nconst uint32_t num_requested = 50; // Request the top 50 matches\n\ndouble* similarities = NULL;\nuint32_t* ids = NULL;\nuint32_t num_returned;\n\n// Run search\nif (janice_search(probe, gallery, num_requested, \nsimilarities, \nids, \nnum_returned) != JANICE_SUCCESS)\n    // ERROR!\n\nnum_requested == num_returned; // This might not be true!\n\n\n\n\njanice_cluster_media\n\n\nCluster a collection of media objects into groups. Each media object may\ncontain 0 or more objects of interest. The resulting array of cluster items\nmust contain a detection object that indicates the object of interest being\nreferred to by the item.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_cluster_media(JaniceConstMedia* input,\n                                               const uint32_t* input_ids,\n                                               const uint32_t num_inputs,\n                                               const uint32_t hint,\n                                               JaniceClusterItem** clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nHint\n\n\nClustering is generally considered to be an ill-defined problem, and most\nalgorithms require some help determining the appropriate number of clusters.\nThe hint parameter helps influence the number of clusters, though the\nimplementation is free to ignore it. The goal of the hint is to provide user\ninput for two use cases:\n\n\n\n\nIf the hint is between 0 - 1 it should be regarded as a purity requirement for the algorithm. A 1 indicates the user wants perfectly pure clusters, even if that means more clusters are returned. A 0 indicates that the user wants very few clusters returned and accepts there may be some errors.\n\n\nIf the hint is \n 1 it represents an estimated upper bound on the number of object types in the set.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nJaniceConstMedia*\n\n\nAn array of media objects.\n\n\n\n\n\n\ninput_ids\n\n\nconst uint32_t*\n\n\nAn array of unique ids for the input objects. This array must be the same size as input.\n\n\n\n\n\n\nnum_inputs\n\n\nconst uint32_t\n\n\nThe size of the input and input_ids arrays\n\n\n\n\n\n\nhint\n\n\nconst uint32_t\n\n\nSee \nhint\n.\n\n\n\n\n\n\nclusters\n\n\nJaniceClusterItem**\n\n\nAn uninitialized pointer to hold an array of cluster items.\n\n\n\n\n\n\nnum_clusters\n\n\nuint32_t*\n\n\nThe size of the clusters array.\n\n\n\n\n\n\n\n\njanice_cluster_templates\n\n\nCluster a collection of previously enrolled templates into groups. The\ntemplates must be enrolled with the \nJaniceCluster\n role.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_cluster_templates(const JaniceTemplate* input,\n                                                   const uint32_t* input_ids,\n                                                   const uint32_t num_inputs,\n                                                   const uint32_t hint,\n                                                   JaniceClusterItem** clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nJaniceConstTemplate*\n\n\nAn array of template objects\n\n\n\n\n\n\ninput_ids\n\n\nconst uint32_t*\n\n\nAn array of unique ids for the input objects. This array must be the same size as input.\n\n\n\n\n\n\nnum_inputs\n\n\nconst uint32_t\n\n\nThe size of the input and input_ids arrays\n\n\n\n\n\n\nhint\n\n\nconst uint32_t\n\n\nSee \nhint\n.\n\n\n\n\n\n\nclusters\n\n\nJaniceClusterItem**\n\n\nAn uninitialized pointer to hold an array of cluster items.\n\n\n\n\n\n\nnum_clusters\n\n\nuint32_t*\n\n\nThe size of the clusters array.\n\n\n\n\n\n\n\n\njanice_finalize\n\n\nDestroy any resources created by \njanice_initialize\n and\nfinalize the application. This should be called once after all other API calls.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_finalize();\n\n\n\n\nThread Safety\n\n\nThis function is thread unsafe.", 
            "title": "Functions"
        }, 
        {
            "location": "/api/functions/#overview", 
            "text": "There are a number of use cases associated with this API. The meaning of the\nconcepts this API tries to convey changes depending on the use case. In the\nfollowing documentation, if the use of the function changes depending on the\nuse case, the description will clearly state what the use is for each relevant\nuse case. If the use of the function does not change, a single description will\nbe provided.  All API functions return an  error code . Because it is universal\nthe return type is not stated in the following documentation.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/functions/#JaniceInitialize", 
            "text": "Initialize global or shared state for the implementation. This function should\nbe called once at the start of the application, before making any other calls\nto the API.", 
            "title": "janice_initialize"
        }, 
        {
            "location": "/api/functions/#JaniceInitializeSignature", 
            "text": "JANICE_EXPORT JaniceError janice_initialize(const char* sdk_path,\n                                            const char* temp_path,\n                                            const char* algorithm,\n                                            const int gpu_dev);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceInitializeThreadSafety", 
            "text": "This function is thread unsafe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceInitializeParameters", 
            "text": "Name  Type  Description      sdk_path  const char*  Path to a  read-only  directory containing the JanICE compliant SDK as specified by the implementor    temp_path  const char*  Path to an existing empty  read-write  directory for use as temporary file storage by the implementation. This path must be guaranteed until  janice_finalize .    algorithm  const char*  An empty string indicating the a default algorithm, or an implementation defined string containing an alternative configuration    gpu_dev  int  An index indicated a GPU device to use. If no GPU is available users should pass -1. If implementors do not offer a GPU solution they can ignore this value.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceTrain", 
            "text": "Train an implementation using new data.", 
            "title": "janice_train"
        }, 
        {
            "location": "/api/functions/#JaniceTrainSignature", 
            "text": "JANICE_EXPORT JaniceError janice_train(const char* data_prefix,\n                                       const char* data_list);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceTrainThreadSafety", 
            "text": "This function is thread unsafe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceTrainParameters", 
            "text": "Name  Type  Description      data_prefix  const char*  A prefix path pointing to the location of training data    data_train  const char*  A list of training data and labels. The format is currently unspecified", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceTrainNotes", 
            "text": "This function is untested, unstable and most likely subject to breaking changes\nin future releases.", 
            "title": "Notes"
        }, 
        {
            "location": "/api/functions/#JaniceErrorToString", 
            "text": "Convert an  error code  into a string for printing.", 
            "title": "janice_error_to_string"
        }, 
        {
            "location": "/api/functions/#JaniceErrorToStringSignature", 
            "text": "JANICE_EXPORT const char* janice_error_to_string(JaniceError error);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceErrorToStringThreadSafety", 
            "text": "This function is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceErrorToStringParameters", 
            "text": "Name  Type  Description      error  JaniceError  An error code", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceErrorToStringReturnValue", 
            "text": "This is the only function in the API that does not return JaniceError . It returns  const char*  which is a\nnull-terminated list of characters that describe the input error.", 
            "title": "Return Value"
        }, 
        {
            "location": "/api/functions/#JaniceSDKVersion", 
            "text": "Query the implementation for the version of the API it was designed to\nimplement. See  the section on software versioning  for more\ninformation on the versioning process for this API.", 
            "title": "janice_sdk_version"
        }, 
        {
            "location": "/api/functions/#JaniceSDKVersionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_sdk_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceSDKVersionThreadSafety", 
            "text": "This function is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters", 
            "text": "Name  Type  Description      major  uint32_t*  The supported major version of the API    minor  uint32_t*  The supported minor version of the API    patch  uint32_t*  The supported patch version of the API", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceCreateMedia", 
            "text": "Create a  JaniceMediaType  object from a file.", 
            "title": "janice_create_media"
        }, 
        {
            "location": "/api/functions/#JaniceCreateMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_media(const char* filename,\n                                              JaniceMedia* media);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceCreateMediaThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceCreateMediaParameters", 
            "text": "Name  Type  Description      filename  const char*  A path to an image or video on disk    media  JaniceMedia*  An uninitialized pointer to a media object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceCreateMediaExample", 
            "text": "JaniceMedia media = NULL;\nif (janice_create_media( example.media ,  media) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceFreeMedia", 
            "text": "Free any memory associated with a  JaniceMediaType  object.", 
            "title": "janice_free_media"
        }, 
        {
            "location": "/api/functions/#JaniceFreeMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_media(JaniceMedia* media);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceFreeMediaThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceFreeMediaParameters", 
            "text": "Name  Type  Description      media  JaniceMedia*  A media object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceFreeMediaExample", 
            "text": "JaniceMedia media; // Where media is a valid media object created previously\nif (janice_free_media( media) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetection", 
            "text": "Create a detection from a known rectangle. This is useful if a human has\nindentified an object of interest and would like to run subsequent API\nfunctions on it. In the case where the input media is a video the given\nrectangle is considered an initial sighting of the object of interest. The\nimplementation may detect additional sightings of the object in successive\nframes.", 
            "title": "janice_create_detection"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_detection(JaniceConstMedia media,\n                                                  const JaniceRect rect,\n                                                  uint32_t frame,\n                                                  JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionFaceRecognition", 
            "text": "The provided rectangle will encapsulate a face in the media.", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionCameraIdentification", 
            "text": "The provided rectangle will encapsulate a region of interest in the media. Often the\nrectangle will simply border the entire image. Note that at this time camera\nidentification is only implemented for images and will return an error if the\nmedia is a video. Because the implementation is image-only the value in the\nframe parameter is ignored.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionParameters", 
            "text": "Name  Type  Description      media  JaniceConstMedia  A media object to create the detection from    rect  const  JaniceRect  A rectangle that bounds the object of interest    frame  uint32_t  An index to the frame in the media the rectangle refers to. If the media is an image this should be 0.    detection  JaniceDetection*  An uninitialized pointer to a detection object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceCreateDetectionExample", 
            "text": "JaniceMedia media; // Where media is a valid media object created previously\n\nJaniceRect rect; // Create a bounding rectangle around an object of interest\nrect.x      = 10; // The rectangle should fall within the bounds of the media\nrect.y      = 10; // This code assumes media width   110 and media height   110\nrect.width  = 100;\nrect.height = 100;\n\nJaniceDetection detection = NULL; // best practice to initialize to NULL\nif (janice_create_detection(media, rect, 0 /* frame */,  detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceDetect", 
            "text": "Automatically detect objects in a media object. See  the paragraph on\ndetection  for an overview of detection in the context of this API.", 
            "title": "janice_detect"
        }, 
        {
            "location": "/api/functions/#JaniceDetectSignature", 
            "text": "JANICE_EXPORT JaniceError janice_detect(JaniceConstMedia media,\n                                        uint32_t min_object_size,\n                                        JaniceDetection* detections,\n                                        uint32_t* num_detections);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceDetectThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceDetectMinimumObjectSize", 
            "text": "This function specifies a minimum object size as one of its parameters. This\nvalue indicates the minimum size of objects that the user would like to see\ndetected. Often, increasing the minimum size can improve runtime of algorithms.\nThe size is in pixels and corresponds to the length of the smaller side of the\nrectangle. This means a detection will be returned if and only if its smaller\nside is larger than the value specified. If the user does not wish to specify a\nminimum width 0 can be provided.", 
            "title": "Minimum Object Size"
        }, 
        {
            "location": "/api/functions/#JaniceDetectFaceRecognition", 
            "text": "This function detects faces in the media.", 
            "title": "Face Recogntion"
        }, 
        {
            "location": "/api/functions/#JaniceDetectCameraIdentification", 
            "text": "This function provides a list of size 1 where the only entry is a detection\nwith a rect that encapsulates the entire image.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/api/functions/#JaniceDetectParameters", 
            "text": "Name  Type  Description      media  JaniceConstMedia  A media object to create the detection from.    min_object_size  uint32_t  A minimum object size. See  Minimum Object Size    detections  JaniceDetection*  An uninitialized array to hold all of the detections detected in the media object. See  the section on memory allocation  for requirements for initialization.    num_detections  uint32_t*  The number of detections detected", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceDetectExample", 
            "text": "JaniceMedia media; // Where media is a valid media object created previously\nconst uint32_t min_object_size = 24; // Only find objects where the smaller\n                                     // side is   24 pixels\nJaniceDetection* detections = NULL; // best practice to initialize to NULL\nuint32_t num_detections; // Will be populated with the size of detections\n\nif (janice_detect(media, min_object_size,  detections,  num_detections) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceDetectionGetInstances", 
            "text": "Get a list of the  JaniceDetectionInstances  that\ncomprise the detection.", 
            "title": "janice_detection_get_instances"
        }, 
        {
            "location": "/api/functions/#JaniceDetectionGetInstancesSignature", 
            "text": "JANICE_EXPORT JaniceError janice_detection_get_instances(JaniceConstDetection detection,\n                                                         JaniceDetectionInstance** instances,\n                                                         uint32_t* num_instances);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceDetectionGetInstancesThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceDetectionGetInstancesParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  A detection object to get instances from    instances  JaniceDetectionInstance**  An uninitialized array to hold the instances that comprise the detection. See  the section on memory allocation  for requirements for initialization.    num_instances  uint32_t*  The number of instances that comprise the detection", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceDetectionGetInstancesExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nJaniceDetectionInstance* instances = NULL; // best practice to intialize to NULL\nuint32_t num_instances; // Will be populated with the size of instances\n\nif (janice_detection_get_instances(detection,  instances,  num_instances) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeDetection", 
            "text": "Serialize a  JaniceDetection  object to a flat buffer.", 
            "title": "janice_serialize_detection"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_detection(JaniceConstDetection detection,\n                                                     unsigned char** data,\n                                                     size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  A detection object to serialize    data  unsigned char**  An uninitialized buffer to hold the flattened data. See  the section on memory allocation  for requirements for initialization.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeDetection", 
            "text": "Deserialize a  JaniceDetection  object from a flat buffer.", 
            "title": "janice_deserialize_detection"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_detection(const unsigned char* data,\n                                                       size_t len,\n                                                       JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters_1", 
            "text": "Name  Type  Description      data  const unsigned char*  A buffer containing data from a flattened detection object.    len  size_t  The length of the flat buffer    detection  JaniceDetection*  An uninitialized detection object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#example", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.detection ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceReadDetection", 
            "text": "Read a detection from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.detection ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_detection"
        }, 
        {
            "location": "/api/functions/#JaniceReadDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_detection(const char* filename,\n                                                JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceReadDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceReadDetectionParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    detection  JaniceDetection*  An uninitialized detection object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceReadDetectionExample", 
            "text": "JaniceDetection detection = NULL;\nif (janice_read_detection( example.detection ,  detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceWriteDetection", 
            "text": "Write a detection to a file on disk. This method is functionally equivalent\nto the following-  JaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.detection ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_detection"
        }, 
        {
            "location": "/api/functions/#JaniceWriteDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_detection(JaniceConstDetection detection,\n                                                 const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceWriteDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/functions/#JaniceWriteDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  The detection object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceWriteDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection created\n                           // previously\nif (janice_write_detection(detection,  example.detection ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceFreeDetection", 
            "text": "Free any memory associated with a  JaniceDetectionType  object.", 
            "title": "janice_free_detection"
        }, 
        {
            "location": "/api/functions/#JaniceFreeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_detection(JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceFreeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceFreeDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceDetection*  A detection object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceFreeDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nif (janice_free_detection( detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceCreateTemplate", 
            "text": "Create a  JaniceTemplate  object from an array of detections.", 
            "title": "janice_create_template"
        }, 
        {
            "location": "/api/functions/#JaniceCreateTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_template(JaniceConstDetection* detections,\n                                                 uint32_t num_detections,\n                                                 JaniceEnrollmentType role,\n                                                 JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceCreateTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceCreateTemplateParameters", 
            "text": "Name  Type  Description      detections  JaniceConstDetection*  An array of detection objects    num_detections  uint32_t  The number of input detections    role  JaniceEnrollmentType  The use case for the template    tmpl  JaniceTemplate*  An uninitialized template object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceCreateTemplateExample", 
            "text": "JaniceDetection* detections; // Where detections is a valid array of valid\n                             // detection objects created previously\nconst uint32_t num_detections = K; // Where K is the number of detections in\n                                   // the detections array\nJaniceEnrollmentType role = Janice1NProbe; // This template will be used as a\n                                           // probe in 1-N search\nJaniceTemplate tmpl = NULL; // Best practice to initialize to NULL\n\nif (janice_create_template(detections, num_detections, rolw,  tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeTemplate", 
            "text": "Serialize a  JaniceTemplate  object to a flat buffer.", 
            "title": "janice_serialize_template"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_template(JaniceConstTemplate tmpl,\n                                                    unsigned char** data,\n                                                    size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceConstTemplate  A template object to serialize    data  unsigned char**  An uninitialized buffer to hold the flattened data. See  the section on memory allocation  for requirements for initialization.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeTemplate", 
            "text": "Deserialize a  JaniceTemplate  object from a flat buffer.", 
            "title": "janice_deserialize_template"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_template(const unsigned char** data,\n                                                      size_t len,\n                                                      JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters_2", 
            "text": "Name  Type  Description      data  const unsigned char*  A buffer containing data from a flattened template object.    len  size_t  The length of the flat buffer    tmpl  JaniceTemplate*  An uninitialized template object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#example_1", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.template ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = NULL; // best practice to initialize to NULL\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceReadTemplate", 
            "text": "Read a template from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.template ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = nullptr;\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_template"
        }, 
        {
            "location": "/api/functions/#JaniceReadTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_template(const char* filename,\n                                               JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceReadTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceReadTemplateParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    tmpl  JaniceTemplate*  An uninitialized template object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceReadTemplateExample", 
            "text": "JaniceTemplate tmpl = NULL;\nif (janice_read_template( example.template ,  tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceWriteTemplate", 
            "text": "Write a template to a file on disk. This method is functionally equivalent\nto the following-  JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.template ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_template"
        }, 
        {
            "location": "/api/functions/#JaniceWriteTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_template(JaniceConstTemplate tmpl,\n                                                const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceWriteTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/functions/#JaniceWriteTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceConstTemplate  The template object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceWriteTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously\nif (janice_write_template(tmpl,  example.template ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceFreeTemplate", 
            "text": "Free any memory associated with a  JaniceTemplateType  object.", 
            "title": "janice_free_template"
        }, 
        {
            "location": "/api/functions/#JaniceFreeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_template(JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceFreeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceFreeTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceTemplate*  A template object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceFreeTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created previously\nif (janice_free_template( tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceVerify", 
            "text": "Compare two templates with the difference expressed as a similarity score.", 
            "title": "janice_verify"
        }, 
        {
            "location": "/api/functions/#JaniceVerifySignature", 
            "text": "JANICE_EXPORT JaniceError janice_verify(JaniceConstTemplate reference,\n                                        JaniceConstTemplate verification,\n                                        double* similarity);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceVerifyThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceVerifySimilarityScore", 
            "text": "This API expects that the comparison of two templates results in a single value\nthat quantifies the similarity between them. A similarity score is constrained\nby the following requirements:  1. Higher scores indicate greater similarity\n2. Scores can be asymmetric. This mean verify(a, b) does not necessarily\n   equal verify(b, a)", 
            "title": "Similarity Score"
        }, 
        {
            "location": "/api/functions/#JaniceVerifyParameters", 
            "text": "Name  Type  Description      reference  JaniceConstTemplate  A reference template. This template was created with the  Janice11Reference  role.    verification  JaniceConstTemplate  A verification template. This template was created with the  Janice11Verification  role.    similarity  double*  A similarity score. See  this section  for more information.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceVerifyExample", 
            "text": "JaniceTemplate reference; // Where reference is a valid template object created\n                          // previously\nJaniceTemplate verification; // Where verification is a valid template object\n                             // created previously\ndouble similarity;\nif (janice_verify(reference, verification,  similarity) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceCreateGallery", 
            "text": "Create a  JaniceGalleryType  object from a list of\ntemplates and unique ids.", 
            "title": "janice_create_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceCreateGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_gallery(JaniceConstTemplate* tmpls,\n                                                const uint32_t* ids,\n                                                JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#thread-safety-janicecreategallerythreadsafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety {: #JaniceCreateGalleryThreadSafety"
        }, 
        {
            "location": "/api/functions/#JaniceCreateGalleryParameters", 
            "text": "Name  Type  Description      tmpls  JaniceConstTemplate*  An array of templates to add to the gallery    ids  const uint32_t*  A set of unique identifiers to associate with the input templates. The  ith  id corresponds to the  ith  input template.    gallery  JaniceGallery*  An uninitialized gallery object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceCreateGalleryExample", 
            "text": "JaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nuint32_t* ids; // Where ids is a valid array of unique unsigned integers that\n               // is the same length as tmpls\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids,  gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryInsert", 
            "text": "Insert a template into a gallery object. The template data should be copied\ninto the gallery as the template may be deleted after this function.", 
            "title": "janice_gallery_insert"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryInsertSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_insert(JaniceGallery gallery,\n                                                JaniceConstTemplate tmpl,\n                                                uint32_t id);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryInsertThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryInsertParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to insert the template into.    tmpl  JaniceConstTemplate  A template object to insert into the gallery.    id  uint32_t  A unique id to associate with the input template", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryInsertExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nuint32_t id; // Where id is a unique integer to associate with tmpl. This\n             // integer should not exist in the gallery\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\n\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryRemove", 
            "text": "Remove a template from a gallery object using its unique id.", 
            "title": "janice_gallery_remove"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryRemoveSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_remove(JaniceGallery gallery,\n                                                uint32_t id);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryRemoveThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters_3", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to remove the template from    id  uint32_t  A unique id associated with a template in the gallery that indicates which template should be remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#example_2", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nconst uint32_t id = 0; // A unique integer id to associate with tmpl.\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously that does not have a template with id '0'\n                       // already inserted in it.\n\n// Insert the template with id 0\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n// Now we can remove the template\nif (janice_gallery_remove(gallery, id) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryPrepare", 
            "text": "Prepare a gallery for search. Implementors can use this function as an\nopportunity to streamline gallery objects to accelerate the search process. The\ncalling convention for this function is  NOT  specified by the API, this\nmeans that this function is not guaranteed to be called before janice_search . It also means that templates can be added\nto a gallery before and after this function is called. Implementations should\nhandle all of these calling conventions. However, users should be aware that\nthis function may be computationally expensive. They should strive to call it\nonly at critical junctions before search and as few times as possible overall.", 
            "title": "janice_gallery_prepare"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryPrepareSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_prepare(JaniceGallery gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryPrepareThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryPrepareParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to prepare", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceGalleryPrepareExample", 
            "text": "JaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nuint32_t* ids; // Where ids is a valid array of unique unsigned integers that\n               // is the same length as tmpls\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nuint32_t id; // Where id is a unique integer id to associate with tmpl.\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids,  gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// It is valid to run search without calling prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare can be called after search\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// Search can be called again right after prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Insert another template into the gallery. This is valid after the gallery\n// has been prepared\nif (janice_gallery_insert(gallery, tmpl, 112) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare the gallery again\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeGallery", 
            "text": "Serialize a  JaniceGallery  object to a flat buffer.", 
            "title": "janice_serialize_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_gallery(JaniceConstGallery gallery,\n                                                   unsigned char** data,\n                                                   size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceConstGallery  A gallery object to serialize    data  unsigned char**  An uninitialized buffer to hold the flattened data. See  the section on memory allocation  for requirements for initialization.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceSerializeGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery created\n                       // previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeGallery", 
            "text": "Deserialize a  JaniceGallery  object from a flat buffer.", 
            "title": "janice_deserialize_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_gallery(const unsigned char** data,\n                                                     size_t len,\n                                                     JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceDeserializeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters_4", 
            "text": "Name  Type  Description      data  const unsigned char*  A buffer containing data from a flattened gallery object.    len  size_t  The length of the flat buffer    gallery  JaniceGallery*  An uninitialized gallery object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#example_3", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.gallery ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceReadGallery", 
            "text": "Read a gallery from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.gallery ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceReadGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_gallery(const char* filename,\n                                              JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceReadGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceReadGalleryParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    gallery  JaniceGallery*  An uninitialized gallery object. See  the section on memory allocation  for requirements for initialization.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceReadGalleryExample", 
            "text": "JaniceGallery gallery = NULL;\nif (janice_read_gallery( example.gallery ,  gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceWriteGallery", 
            "text": "Write a gallery to a file on disk. This method is functionally equivalent\nto the following-  JaniceGallery gallery; // Where gallery is a valid gallery created previously.\n\nunsigned char* buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.gallery ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceWriteGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_gallery(JaniceConstGallery gallery,\n                                               const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceWriteGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/functions/#JaniceWriteGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceConstGallery  The gallery object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceWriteGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery created previously\nif (janice_write_gallery(gallery,  example.gallery ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceFreeGallery", 
            "text": "Free any memory associated with a  JaniceGalleryType  object.", 
            "title": "janice_free_gallery"
        }, 
        {
            "location": "/api/functions/#JaniceFreeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_gallery(JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceFreeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceFreeGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery*  A gallery object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceFreeGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery object created previously\nif (janice_free_gallery( gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceSearch", 
            "text": "Compute 1-N search results between a query template object and a target gallery\nobject. The function allocates two arrays of equal size, one containing similarity scores  and the other containing the\nunique id of the template the score was computed with (along with the query).\nOften it is desirable (and perhaps computationally efficient) to only see the\ntop K scores out of N possible templates. The option to set a K is provided to\nthe user as part of the function parameters.", 
            "title": "janice_search"
        }, 
        {
            "location": "/api/functions/#JaniceSearchSignature", 
            "text": "JANICE_EXPORT JaniceError janice_search(JaniceConstTemplate probe,\n                                        JaniceConstGallery gallery,\n                                        uint32_t num_requested,\n                                        double** similarities,\n                                        uint32_t** ids,\n                                        uint32_t* num_returned);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceSearchThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceSearchParameters", 
            "text": "Name  Type  Description      probe  JaniceConstTemplate  A template object to use as a query    gallery  JaniceConstGallery  A gallery object to search against    num_requested  uint32_t  The number of requested returns. If the user would like as many returns as there are templates in the gallery they can pass this parameter with the value 0.    similarities  double**  An array of  similarity scores . The scores are expected to be sorted in descending order (i.e. the highest scores is stored at index 0).    ids  uint32_t**  An array of unique ids identifying the target templates associated with the similarity scores. This array must be the same size as the similarities array. The  ith  id corresponds with the  ith  similarity.    num_returned  uint32_t*  The number of elements in the similarities and ids arrays. This number can be different from  num_requested .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceSearchExample", 
            "text": "JaniceTemplate probe;  // Where probe is a valid template object created\n                       // previously\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\nconst uint32_t num_requested = 50; // Request the top 50 matches\n\ndouble* similarities = NULL;\nuint32_t* ids = NULL;\nuint32_t num_returned;\n\n// Run search\nif (janice_search(probe, gallery, num_requested,  similarities,  ids,  num_returned) != JANICE_SUCCESS)\n    // ERROR!\n\nnum_requested == num_returned; // This might not be true!", 
            "title": "Example"
        }, 
        {
            "location": "/api/functions/#JaniceClusterMedia", 
            "text": "Cluster a collection of media objects into groups. Each media object may\ncontain 0 or more objects of interest. The resulting array of cluster items\nmust contain a detection object that indicates the object of interest being\nreferred to by the item.", 
            "title": "janice_cluster_media"
        }, 
        {
            "location": "/api/functions/#JaniceClusterMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_cluster_media(JaniceConstMedia* input,\n                                               const uint32_t* input_ids,\n                                               const uint32_t num_inputs,\n                                               const uint32_t hint,\n                                               JaniceClusterItem** clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceClusterMediaThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#JaniceClusterMediaHint", 
            "text": "Clustering is generally considered to be an ill-defined problem, and most\nalgorithms require some help determining the appropriate number of clusters.\nThe hint parameter helps influence the number of clusters, though the\nimplementation is free to ignore it. The goal of the hint is to provide user\ninput for two use cases:   If the hint is between 0 - 1 it should be regarded as a purity requirement for the algorithm. A 1 indicates the user wants perfectly pure clusters, even if that means more clusters are returned. A 0 indicates that the user wants very few clusters returned and accepts there may be some errors.  If the hint is   1 it represents an estimated upper bound on the number of object types in the set.", 
            "title": "Hint"
        }, 
        {
            "location": "/api/functions/#JaniceClusterMediaParameters", 
            "text": "Name  Type  Description      input  JaniceConstMedia*  An array of media objects.    input_ids  const uint32_t*  An array of unique ids for the input objects. This array must be the same size as input.    num_inputs  const uint32_t  The size of the input and input_ids arrays    hint  const uint32_t  See  hint .    clusters  JaniceClusterItem**  An uninitialized pointer to hold an array of cluster items.    num_clusters  uint32_t*  The size of the clusters array.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceClusterTemplates", 
            "text": "Cluster a collection of previously enrolled templates into groups. The\ntemplates must be enrolled with the  JaniceCluster  role.", 
            "title": "janice_cluster_templates"
        }, 
        {
            "location": "/api/functions/#JaniceClusterTemplatesSignature", 
            "text": "JANICE_EXPORT JaniceError janice_cluster_templates(const JaniceTemplate* input,\n                                                   const uint32_t* input_ids,\n                                                   const uint32_t num_inputs,\n                                                   const uint32_t hint,\n                                                   JaniceClusterItem** clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#JaniceClusterTemplatesThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/functions/#parameters_5", 
            "text": "Name  Type  Description      input  JaniceConstTemplate*  An array of template objects    input_ids  const uint32_t*  An array of unique ids for the input objects. This array must be the same size as input.    num_inputs  const uint32_t  The size of the input and input_ids arrays    hint  const uint32_t  See  hint .    clusters  JaniceClusterItem**  An uninitialized pointer to hold an array of cluster items.    num_clusters  uint32_t*  The size of the clusters array.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/functions/#JaniceFinalize", 
            "text": "Destroy any resources created by  janice_initialize  and\nfinalize the application. This should be called once after all other API calls.", 
            "title": "janice_finalize"
        }, 
        {
            "location": "/api/functions/#JaniceFinalizeSignature", 
            "text": "JANICE_EXPORT JaniceError janice_finalize();", 
            "title": "Signature"
        }, 
        {
            "location": "/api/functions/#thread-safety", 
            "text": "This function is thread unsafe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/interfaces/cpp/", 
            "text": "WORK IN PROGRESS", 
            "title": "C++"
        }, 
        {
            "location": "/interfaces/cpp/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/python/", 
            "text": "WORK IN PROGRESS", 
            "title": "Python"
        }, 
        {
            "location": "/interfaces/python/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/csharp/", 
            "text": "WORK IN PROGRESS", 
            "title": "C#"
        }, 
        {
            "location": "/interfaces/csharp/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/java/", 
            "text": "WORK IN PROGRESS", 
            "title": "Java"
        }, 
        {
            "location": "/interfaces/java/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "/*******************************************************************************\n * Copyright (c) 2013 Noblis, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and/or associated documentation files (the\n * \nMaterials\n), to deal in the Materials without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Materials, and to\n * permit persons to whom the Materials are furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Materials.\n *\n * THE MATERIALS ARE PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n ******************************************************************************/", 
            "title": "License"
        }
    ]
}