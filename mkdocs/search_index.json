{
    "docs": [
        {
            "location": "/", 
            "text": "JanICE API\n\n\nThe JanICE API is a \nC\n API that provides a common interface between computer vision\nalgorithms and agencies and entities that would like to use them. The API consists\nof a core header file defining required \nC\n functions. It also defines a number of interfaces to other languages on top of the \nC\n API.\n\n\nThe documentation for the \nC\n API is available \nhere\n.\n\n\nThere are currently interfaces for:\n\n\nThere are plans to write interfaces for:\n\n\n\n\nC++\n\n\nPython\n\n\nC#\n\n\nJava\n\n\n\n\nAbout\n\n\n\n    \n\n\n\n\n\nComputer vision is a rapidly expanding and improving field that has seen significant\nprogress in it's capabilities over the past decade. Government agencies can leverage\ncomputer vision algorithms to better understand images and videos that they ingest.\nThis in turn can lead to improved response times, increased public safety, and numerous\nother benefits. The JanICE API provides a common framework that commercial vendors and\ngovernment agencies can use to ease integration between algorithms and use cases. The\nAPI aims to cover a number of different Computer Vision subproblems. At this time these\nproblems include:\n\n\n\n\nFace Recognition\n\n\nCamera Identification\n\n\n\n\nSome function calls serve multiple use cases in different ways. In those cases the function documentation strives to clearly indicate the differences. If no differences are indicated it means that the function is universal in that it applies the same to each subproblem addressed by the API.\n\n\nThis work is being sponsored by The Department of Homeland Security; Science and Technology Directorate.\n\n\nFocus Areas\n\n\nFace Recognition\n\n\nFacial recognition has emerged as a key technology for government agencies to efficiently triage and analyze large data streams. A large ecosystem of facial recognition algorithms already exists from a variety of sources including commercial vendors, government programs and academia. However, integrating this important technology into existing technology stacks is a difficult and expensive endeavor. The JanICE API aims to address this problem by functioning as a compatibility layer between users and the algorithms. Users can write their applications on \"top\" of the API while algorithm providers will implement their algorithms \"beneath\" the API. This means that users can write their applications independent of any single FR algorithm and gives them the freedom to select the algorithm or algorithms that best serve their specific use case without worrying about integration. Algorithm providers will be able to serve their algorithms across teams and agencies without having to integrate with the different tools and services of each specific team.\n\n\nCamera Identification\n\n\nCamera identification provides the capability to use sensor pattern noise (SPN) to identify images (still and video) that have been captured using the same source camera device. Since the SPN generation and matching processes are similar to biometric template generation and matching, the JanICE functionality can be adapted for this purpose. Likewise the use cases are similar in that 1:1, 1:N, and clustering capabilities are needed. (The latter two implying the existence of a gallery of imagery for which SPN has been calculated.) This also allows both FR and Camera Identification modules (algorithms) to be deployed within the same application/platform.\n\n\nLicense\n\n\nThe API is provided under the MIT license(LICENSE.txt) and is\n\nfree for academic and commercial use\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/#janice-api", 
            "text": "The JanICE API is a  C  API that provides a common interface between computer vision\nalgorithms and agencies and entities that would like to use them. The API consists\nof a core header file defining required  C  functions. It also defines a number of interfaces to other languages on top of the  C  API.  The documentation for the  C  API is available  here .  There are currently interfaces for:  There are plans to write interfaces for:   C++  Python  C#  Java", 
            "title": "JanICE API"
        }, 
        {
            "location": "/#about", 
            "text": "Computer vision is a rapidly expanding and improving field that has seen significant\nprogress in it's capabilities over the past decade. Government agencies can leverage\ncomputer vision algorithms to better understand images and videos that they ingest.\nThis in turn can lead to improved response times, increased public safety, and numerous\nother benefits. The JanICE API provides a common framework that commercial vendors and\ngovernment agencies can use to ease integration between algorithms and use cases. The\nAPI aims to cover a number of different Computer Vision subproblems. At this time these\nproblems include:   Face Recognition  Camera Identification   Some function calls serve multiple use cases in different ways. In those cases the function documentation strives to clearly indicate the differences. If no differences are indicated it means that the function is universal in that it applies the same to each subproblem addressed by the API.  This work is being sponsored by The Department of Homeland Security; Science and Technology Directorate.", 
            "title": "About"
        }, 
        {
            "location": "/#focus-areas", 
            "text": "", 
            "title": "Focus Areas"
        }, 
        {
            "location": "/#face-recognition", 
            "text": "Facial recognition has emerged as a key technology for government agencies to efficiently triage and analyze large data streams. A large ecosystem of facial recognition algorithms already exists from a variety of sources including commercial vendors, government programs and academia. However, integrating this important technology into existing technology stacks is a difficult and expensive endeavor. The JanICE API aims to address this problem by functioning as a compatibility layer between users and the algorithms. Users can write their applications on \"top\" of the API while algorithm providers will implement their algorithms \"beneath\" the API. This means that users can write their applications independent of any single FR algorithm and gives them the freedom to select the algorithm or algorithms that best serve their specific use case without worrying about integration. Algorithm providers will be able to serve their algorithms across teams and agencies without having to integrate with the different tools and services of each specific team.", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/#camera-identification", 
            "text": "Camera identification provides the capability to use sensor pattern noise (SPN) to identify images (still and video) that have been captured using the same source camera device. Since the SPN generation and matching processes are similar to biometric template generation and matching, the JanICE functionality can be adapted for this purpose. Likewise the use cases are similar in that 1:1, 1:N, and clustering capabilities are needed. (The latter two implying the existence of a gallery of imagery for which SPN has been calculated.) This also allows both FR and Camera Identification modules (algorithms) to be deployed within the same application/platform.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/#license", 
            "text": "The API is provided under the MIT license(LICENSE.txt) and is free for academic and commercial use .", 
            "title": "License"
        }, 
        {
            "location": "/api/software_concepts/", 
            "text": "Error Handling\n\n\nThe API handles errors using return codes. Valid return codes are defined\n\nhere\n. In general, it is assumed that new memory is only\nallocated if a function returns \nJANICE_SUCCESS\n. Therefore,\n\nimplementors are REQUIRED to deallocate any memory allocated during a\nfunction call if that function returns an error.\n\n\nMemory Allocation\n\n\nThe API often passes unallocated pointers to functions for the\nimplementor to allocate appropriately. This is indicated if the type of a\nfunction input is \nJaniceObject**\n, or in the case of a utility\n\ntypedef\n \nJaniceTypedef*\n. It is considered a best\npractice for unallocated pointers to be initialized to \nNULL\n before\nthey are passed to a function, but this is not guaranteed. It is the\nresponsibility of the users of the API to ensure that pointers do not point to\nvalid data before they are passed to functions in which they are modified, as\nthis would cause memory leaks.\n\n\nThread Safety\n\n\nAll functions are marked one of:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nThread safe\n\n\nCan be called simultaneously from multiple threads, even when the invocations use shared data.\n\n\n\n\n\n\nReentrant\n\n\nCan be called simultaneously from multiple threads, but only if each invocation uses its own data.\n\n\n\n\n\n\nThread unsafe\n\n\nCan not be called simultaneously from multiple threads.\n\n\n\n\n\n\n\n\nCompiling\n\n\nDefine \nJANICE_LIBRARY\n during compilation to export JanICE symbols.\n\n\nVersioning\n\n\nThis API follows the \nsemantic versioning\n paradigm. Each\nreleased iteration is tagged with a major.minor.patch version. A change in\nthe major version indicates a breaking change. A change in the minor version\nindicates a backwards-compatible change. A change in the patch version\nindicates a backwards-compatible bug fix.", 
            "title": "Software Concepts"
        }, 
        {
            "location": "/api/software_concepts/#ErrorHandling", 
            "text": "The API handles errors using return codes. Valid return codes are defined here . In general, it is assumed that new memory is only\nallocated if a function returns  JANICE_SUCCESS . Therefore, implementors are REQUIRED to deallocate any memory allocated during a\nfunction call if that function returns an error.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/api/software_concepts/#MemoryAllocation", 
            "text": "The API often passes unallocated pointers to functions for the\nimplementor to allocate appropriately. This is indicated if the type of a\nfunction input is  JaniceObject** , or in the case of a utility typedef   JaniceTypedef* . It is considered a best\npractice for unallocated pointers to be initialized to  NULL  before\nthey are passed to a function, but this is not guaranteed. It is the\nresponsibility of the users of the API to ensure that pointers do not point to\nvalid data before they are passed to functions in which they are modified, as\nthis would cause memory leaks.", 
            "title": "Memory Allocation"
        }, 
        {
            "location": "/api/software_concepts/#ThreadSafety", 
            "text": "All functions are marked one of:     Type  Description      Thread safe  Can be called simultaneously from multiple threads, even when the invocations use shared data.    Reentrant  Can be called simultaneously from multiple threads, but only if each invocation uses its own data.    Thread unsafe  Can not be called simultaneously from multiple threads.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/software_concepts/#Compiling", 
            "text": "Define  JANICE_LIBRARY  during compilation to export JanICE symbols.", 
            "title": "Compiling"
        }, 
        {
            "location": "/api/software_concepts/#Versioning", 
            "text": "This API follows the  semantic versioning  paradigm. Each\nreleased iteration is tagged with a major.minor.patch version. A change in\nthe major version indicates a breaking change. A change in the minor version\nindicates a backwards-compatible change. A change in the patch version\nindicates a backwards-compatible bug fix.", 
            "title": "Versioning"
        }, 
        {
            "location": "/api/misc/functions/", 
            "text": "janice_initialize\n\n\nInitialize global or shared state for the implementation. This function should\nbe called once at the start of the application, before making any other calls\nto the API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_initialize(const char* sdk_path,\n                                            const char* temp_path,\n                                            const char* algorithm,\n                                            const int gpu_dev);\n\n\n\n\nThread Safety\n\n\nThis function is thread unsafe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsdk_path\n\n\nconst char*\n\n\nPath to a \nread-only\n directory containing the JanICE compliant SDK as specified by the implementor\n\n\n\n\n\n\ntemp_path\n\n\nconst char*\n\n\nPath to an existing empty \nread-write\n directory for use as temporary file storage by the implementation. This path must be guaranteed until \njanice_finalize\n.\n\n\n\n\n\n\nalgorithm\n\n\nconst char*\n\n\nAn empty string indicating the a default algorithm, or an implementation defined string containing an alternative configuration\n\n\n\n\n\n\ngpu_dev\n\n\nint\n\n\nAn index indicated a GPU device to use. If no GPU is available users should pass -1. If implementors do not offer a GPU solution they can ignore this value.\n\n\n\n\n\n\n\n\njanice_api_version\n\n\nQuery the implementation for the version of the JanICE API it was designed to\nimplement. See\n\nthe section on software versioning\n for\nmore information on the versioning process for this API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_api_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmajor\n\n\nuint32_t*\n\n\nThe supported major version of the API\n\n\n\n\n\n\nminor\n\n\nuint32_t*\n\n\nThe supported minor version of the API\n\n\n\n\n\n\npatch\n\n\nuint32_t*\n\n\nThe supported patch version of the API\n\n\n\n\n\n\n\n\njanice_sdk_version\n\n\nQuery the implementation for its SDK version.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_sdk_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmajor\n\n\nuint32_t*\n\n\nThe major version of the SDK\n\n\n\n\n\n\nminor\n\n\nuint32_t*\n\n\nThe minor version of the SDK\n\n\n\n\n\n\npatch\n\n\nuint32_t*\n\n\nThe patch version of the SDK\n\n\n\n\n\n\n\n\njanice_finalize\n\n\nDestroy any resources created by \njanice_initialize\n and\nfinalize the application. This should be called once after all other API calls.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_finalize();\n\n\n\n\nThread Safety\n\n\nThis function is thread unsafe.", 
            "title": "Functions"
        }, 
        {
            "location": "/api/misc/functions/#JaniceInitialize", 
            "text": "Initialize global or shared state for the implementation. This function should\nbe called once at the start of the application, before making any other calls\nto the API.", 
            "title": "janice_initialize"
        }, 
        {
            "location": "/api/misc/functions/#JaniceInitializeSignature", 
            "text": "JANICE_EXPORT JaniceError janice_initialize(const char* sdk_path,\n                                            const char* temp_path,\n                                            const char* algorithm,\n                                            const int gpu_dev);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/misc/functions/#JaniceInitializeThreadSafety", 
            "text": "This function is thread unsafe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/misc/functions/#JaniceInitializeParameters", 
            "text": "Name  Type  Description      sdk_path  const char*  Path to a  read-only  directory containing the JanICE compliant SDK as specified by the implementor    temp_path  const char*  Path to an existing empty  read-write  directory for use as temporary file storage by the implementation. This path must be guaranteed until  janice_finalize .    algorithm  const char*  An empty string indicating the a default algorithm, or an implementation defined string containing an alternative configuration    gpu_dev  int  An index indicated a GPU device to use. If no GPU is available users should pass -1. If implementors do not offer a GPU solution they can ignore this value.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/misc/functions/#JaniceAPIVersion", 
            "text": "Query the implementation for the version of the JanICE API it was designed to\nimplement. See the section on software versioning  for\nmore information on the versioning process for this API.", 
            "title": "janice_api_version"
        }, 
        {
            "location": "/api/misc/functions/#JaniceAPIVersionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_api_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/misc/functions/#JaniceAPIVersionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/misc/functions/#JaniceAPIVersionParameters", 
            "text": "Name  Type  Description      major  uint32_t*  The supported major version of the API    minor  uint32_t*  The supported minor version of the API    patch  uint32_t*  The supported patch version of the API", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/misc/functions/#JaniceSDKVersion", 
            "text": "Query the implementation for its SDK version.", 
            "title": "janice_sdk_version"
        }, 
        {
            "location": "/api/misc/functions/#JaniceSDKVersionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_sdk_version(uint32_t* major,\n                                             uint32_t* minor,\n                                             uint32_t* patch);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/misc/functions/#JaniceSDKVersionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/misc/functions/#JaniceSDKVersionParameters", 
            "text": "Name  Type  Description      major  uint32_t*  The major version of the SDK    minor  uint32_t*  The minor version of the SDK    patch  uint32_t*  The patch version of the SDK", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/misc/functions/#JaniceFinalize", 
            "text": "Destroy any resources created by  janice_initialize  and\nfinalize the application. This should be called once after all other API calls.", 
            "title": "janice_finalize"
        }, 
        {
            "location": "/api/misc/functions/#JaniceFinalizeSignature", 
            "text": "JANICE_EXPORT JaniceError janice_finalize();", 
            "title": "Signature"
        }, 
        {
            "location": "/api/misc/functions/#JaniceFinalizeThreadSafety", 
            "text": "This function is thread unsafe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/errors/overview/", 
            "text": "Every function in the JanICE \nC\n API returns an error code when executed. In the case of successful application \nJANICE_SUCCESS\n is returned, otherwise a code indicating the specific issue is returned. The error codes are enumerated using the\n\nJaniceError\n type.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/errors/enums/", 
            "text": "JaniceError\n\n\nThe error codes defined in the JanICE \nC\n API\n\n\n\n\n\n\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nJANICE_SUCCESS\n\n\nNo error\n\n\n\n\n\n\nJANICE_UNKNOWN_ERROR\n\n\nCatch all error code\n\n\n\n\n\n\nJANICE_OUT_OF_MEMORY\n\n\nOut of memory error\n\n\n\n\n\n\nJANICE_INVALID_SDK_PATH\n\n\nInvalid SDK location\n\n\n\n\n\n\nJANICE_BAD_SDK_CONFIG\n\n\nInvalid SDK configuration\n\n\n\n\n\n\nJANICE_BAD_LICENSE\n\n\nIncorrect license file\n\n\n\n\n\n\nJANICE_MISSING_DATA\n\n\nMissing SDK data\n\n\n\n\n\n\nJANICE_INVALID_GPU\n\n\nThe GPU is not functioning\n\n\n\n\n\n\nJANICE_OPEN_ERROR\n\n\nFailed to open a file\n\n\n\n\n\n\nJANICE_READ_ERROR\n\n\nFailed to read from a file\n\n\n\n\n\n\nJANICE_WRITE_ERROR\n\n\nFailed to write to a file\n\n\n\n\n\n\nJANICE_PARSE_ERROR\n\n\nFailed to parse a file\n\n\n\n\n\n\nJANICE_INVALID_MEDIA\n\n\nFailed to decode a media file\n\n\n\n\n\n\nJANICE_DUPLICATE_ID\n\n\nTemplate id already exists in a gallery\n\n\n\n\n\n\nJANICE_MISSING_ID\n\n\nTemplate id can't be found\n\n\n\n\n\n\nJANICE_MISSING_FILE_NAME\n\n\nAn expected file name is not given\n\n\n\n\n\n\nJANICE_INCORRECT_ROLE\n\n\nIncorrect template role\n\n\n\n\n\n\nJANICE_FAILURE_TO_ENROLL\n\n\nCould not construct a template\n\n\n\n\n\n\nJANICE_FAILURE_TO_SERIALIZE\n\n\nCould not serialize a data structure\n\n\n\n\n\n\nJANICE_FAILURE_TO_DESERIALIZE\n\n\nCould not deserialize a data structure\n\n\n\n\n\n\nJANICE_NOT_IMPLEMENTED\n\n\nOptional function return\n\n\n\n\n\n\nJANICE_NUM_ERRORS\n\n\nUtility to iterate over all errors", 
            "title": "Enums"
        }, 
        {
            "location": "/api/errors/enums/#JaniceError", 
            "text": "The error codes defined in the JanICE  C  API     Code  Description      JANICE_SUCCESS  No error    JANICE_UNKNOWN_ERROR  Catch all error code    JANICE_OUT_OF_MEMORY  Out of memory error    JANICE_INVALID_SDK_PATH  Invalid SDK location    JANICE_BAD_SDK_CONFIG  Invalid SDK configuration    JANICE_BAD_LICENSE  Incorrect license file    JANICE_MISSING_DATA  Missing SDK data    JANICE_INVALID_GPU  The GPU is not functioning    JANICE_OPEN_ERROR  Failed to open a file    JANICE_READ_ERROR  Failed to read from a file    JANICE_WRITE_ERROR  Failed to write to a file    JANICE_PARSE_ERROR  Failed to parse a file    JANICE_INVALID_MEDIA  Failed to decode a media file    JANICE_DUPLICATE_ID  Template id already exists in a gallery    JANICE_MISSING_ID  Template id can't be found    JANICE_MISSING_FILE_NAME  An expected file name is not given    JANICE_INCORRECT_ROLE  Incorrect template role    JANICE_FAILURE_TO_ENROLL  Could not construct a template    JANICE_FAILURE_TO_SERIALIZE  Could not serialize a data structure    JANICE_FAILURE_TO_DESERIALIZE  Could not deserialize a data structure    JANICE_NOT_IMPLEMENTED  Optional function return    JANICE_NUM_ERRORS  Utility to iterate over all errors", 
            "title": "JaniceError"
        }, 
        {
            "location": "/api/errors/functions/", 
            "text": "janice_error_to_string\n\n\nConvert an \nerror code\n into a string for printing.\n\n\nSignature\n\n\nJANICE_EXPORT const char* janice_error_to_string(JaniceError error);\n\n\n\n\nThread Safety\n\n\nThis function is thread safe.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nerror\n\n\nJaniceError\n\n\nAn error code\n\n\n\n\n\n\n\n\nReturn Value\n\n\nThis is the only function in the API that does not return\n\nJaniceError\n. It returns \nconst char*\n which is a\nnull-terminated list of characters that describe the input error.", 
            "title": "Functions"
        }, 
        {
            "location": "/api/errors/functions/#JaniceErrorToString", 
            "text": "Convert an  error code  into a string for printing.", 
            "title": "janice_error_to_string"
        }, 
        {
            "location": "/api/errors/functions/#JaniceErrorToStringSignature", 
            "text": "JANICE_EXPORT const char* janice_error_to_string(JaniceError error);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/errors/functions/#JaniceErrorToStringThreadSafety", 
            "text": "This function is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/errors/functions/#JaniceErrorToStringParameters", 
            "text": "Name  Type  Description      error  JaniceError  An error code", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/errors/functions/#JaniceErrorToStringReturnValue", 
            "text": "This is the only function in the API that does not return JaniceError . It returns  const char*  which is a\nnull-terminated list of characters that describe the input error.", 
            "title": "Return Value"
        }, 
        {
            "location": "/api/io/overview/", 
            "text": "As a computer vision API it is a requirement that images and videos are loaded\ninto a common structure that can be processed by the rest of the API. In this\ncase, we strive to isolate the I/O functions from the rest of the API. This\nserves three purposes:\n\n\n\n\nIt allows implementations to be agnostic to the method and type of image storage, compression techniques and other factors\n\n\nIt keeps implementations from having to worry about licenses, patents and other factors that can arise from distributing proprietary image formats\n\n\nIt allows implementations to be \"future-proof\" with regards to future developments of image or video formats\n\n\n\n\nTo accomplish this goal the API defines a simple interface of two structures,\n\nJaniceImageType\n and \n\nJaniceMediaType\n which correspond to\na single image or frame and an entire video respectively. These interfaces\nallow pixel-level access for implementations and can be changed independently\nto work with new formats.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/io/structs/", 
            "text": "JaniceImageType\n\n\nAn interface representing a single frame or an image\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchannels\n\n\nuint32_t\n\n\nThe number of channels in the image\n\n\n\n\n\n\nrows\n\n\nuint32_t\n\n\nThe number of rows in the image\n\n\n\n\n\n\ncols\n\n\nuint32_t\n\n\nThe number of columns in the image\n\n\n\n\n\n\ndata\n\n\nJaniceBuffer\n\n\nA contiguous, row-major array containing pixel data\n\n\n\n\n\n\nowner\n\n\nbool\n\n\nTrue if the image owns its data and should delete it, false otherwise.\n\n\n\n\n\n\n\n\nJaniceMediaIteratorType\n\n\nAn opaque object that iterates over the frames in a media object. The object\ncan contain any implementation specific variables or state required to\nimplement the iteration interface described \nhere\n.\n\n\nJaniceMediaType\n\n\nAn interface representing an image or video\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nchar*\n\n\nA null-terminated string that contains the location of the media on disk.\n\n\n\n\n\n\nchannels\n\n\nuint32_t\n\n\nThe number of channels in the media\n\n\n\n\n\n\nrows\n\n\nuint32_t\n\n\nThe number of rows in the media\n\n\n\n\n\n\ncols\n\n\nuint32_t\n\n\nThe number of columns in the media\n\n\n\n\n\n\nframes\n\n\nuint32_t\n\n\nThe number of frames in the media", 
            "title": "Structs"
        }, 
        {
            "location": "/api/io/structs/#JaniceImageType", 
            "text": "An interface representing a single frame or an image", 
            "title": "JaniceImageType"
        }, 
        {
            "location": "/api/io/structs/#JaniceImageTypeFields", 
            "text": "Name  Type  Description      channels  uint32_t  The number of channels in the image    rows  uint32_t  The number of rows in the image    cols  uint32_t  The number of columns in the image    data  JaniceBuffer  A contiguous, row-major array containing pixel data    owner  bool  True if the image owns its data and should delete it, false otherwise.", 
            "title": "Fields"
        }, 
        {
            "location": "/api/io/structs/#JaniceMediaIteratorType", 
            "text": "An opaque object that iterates over the frames in a media object. The object\ncan contain any implementation specific variables or state required to\nimplement the iteration interface described  here .", 
            "title": "JaniceMediaIteratorType"
        }, 
        {
            "location": "/api/io/structs/#JaniceMediaType", 
            "text": "An interface representing an image or video", 
            "title": "JaniceMediaType"
        }, 
        {
            "location": "/api/io/structs/#JaniceMediaTypeFields", 
            "text": "Name  Type  Description      filename  char*  A null-terminated string that contains the location of the media on disk.    channels  uint32_t  The number of channels in the media    rows  uint32_t  The number of rows in the media    cols  uint32_t  The number of columns in the media    frames  uint32_t  The number of frames in the media", 
            "title": "Fields"
        }, 
        {
            "location": "/api/io/typedefs/", 
            "text": "JaniceBuffer\n\n\nAn array of uint8_t\n\n\nSignature\n\n\ntypedef uint8_t* JaniceBuffer;\n\n\n\n\nJaniceImage\n\n\nA pointer to a \nJaniceImageType\n object\n\n\nSignature\n\n\ntypedef struct JaniceImageType* JaniceImage;\n\n\n\n\nJaniceConstImage\n\n\nA pointer to a constant \nJaniceImageType\n object\n\n\nSignature\n\n\ntypedef const struct JaniceImageType* JaniceConstImage;\n\n\n\n\nJaniceMediaIterator\n\n\nA pointer to a \nJaniceMediaIteratorType\n object.\n\n\nSignature\n\n\ntypedef struct JaniceMediaIteratorType* JaniceMediaIterator;\n\n\n\n\nJaniceMedia\n\n\nA pointer to a \nJaniceMediaType\n object\n\n\nSignature\n\n\ntypedef struct JaniceMediaType* JaniceMedia;\n\n\n\n\nJaniceConstMedia\n\n\nA pointer to a constant \nJaniceMediaType\n object\n\n\nSignature\n\n\ntypedef const struct JaniceMediaType* JaniceConstMedia;\n\n\n\n\nJaniceMedias\n\n\nAn array of \nJaniceMedia\n objects\n\n\nSignature\n\n\ntypedef JaniceMedia* JaniceMedias;\n\n\n\n\nJaniceConstMedias\n\n\nAn array of \nJaniceConstMedia\n objects\n\n\nSignature\n\n\ntypedef JaniceConstMedia* JaniceConstMedias;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceBuffer", 
            "text": "An array of uint8_t", 
            "title": "JaniceBuffer"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceBufferSignature", 
            "text": "typedef uint8_t* JaniceBuffer;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceImage", 
            "text": "A pointer to a  JaniceImageType  object", 
            "title": "JaniceImage"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceImageSignature", 
            "text": "typedef struct JaniceImageType* JaniceImage;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstImage", 
            "text": "A pointer to a constant  JaniceImageType  object", 
            "title": "JaniceConstImage"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstImageSignature", 
            "text": "typedef const struct JaniceImageType* JaniceConstImage;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceMediaIterator", 
            "text": "A pointer to a  JaniceMediaIteratorType  object.", 
            "title": "JaniceMediaIterator"
        }, 
        {
            "location": "/api/io/typedefs/#signature", 
            "text": "typedef struct JaniceMediaIteratorType* JaniceMediaIterator;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceMedia", 
            "text": "A pointer to a  JaniceMediaType  object", 
            "title": "JaniceMedia"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceMediaSignature", 
            "text": "typedef struct JaniceMediaType* JaniceMedia;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstMedia", 
            "text": "A pointer to a constant  JaniceMediaType  object", 
            "title": "JaniceConstMedia"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstMediaSignature", 
            "text": "typedef const struct JaniceMediaType* JaniceConstMedia;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceMedias", 
            "text": "An array of  JaniceMedia  objects", 
            "title": "JaniceMedias"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceMediasSignature", 
            "text": "typedef JaniceMedia* JaniceMedias;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstMedias", 
            "text": "An array of  JaniceConstMedia  objects", 
            "title": "JaniceConstMedias"
        }, 
        {
            "location": "/api/io/typedefs/#JaniceConstMediasSignature", 
            "text": "typedef JaniceConstMedia* JaniceConstMedias;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/", 
            "text": "janice_image_access\n\n\nGet a pixel value at a given row, column and channel.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_image_access(JaniceConstImage image,\n                                              uint32_t channel,\n                                              uint32_t row,\n                                              uint32_t col,\n                                              uint8_t* value);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nJaniceConstImage\n\n\nAn image object\n\n\n\n\n\n\nchannel\n\n\nuint32_t\n\n\nThe channel to access. Must be less than image-\nchannels.\n\n\n\n\n\n\nrow\n\n\nuint32_t\n\n\nThe row to access. Must be less than image-\nrows.\n\n\n\n\n\n\ncol\n\n\nuint32_t\n\n\nThe column to access. Must be less that image-\ncols.\n\n\n\n\n\n\nvalue\n\n\nuint8_t*\n\n\nA container for the value at the given index.\n\n\n\n\n\n\n\n\njanice_free_image\n\n\nFree any memory associated with a \nJaniceImage\n.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_image(JaniceImage* image);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nJaniceImage*\n\n\nAn image object to free\n\n\n\n\n\n\n\n\njanice_media_it_next\n\n\nGet the next frame or load the image from a media iterator.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_media_it_next(JaniceMediaIterator it,\n                                               JaniceImage* image);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator\n\n\nA media iterator object to query\n\n\n\n\n\n\nimage\n\n\nJaniceImage*\n\n\nAn uninitialized pointer to an image object to hold the next frame or image\n\n\n\n\n\n\n\n\njanice_media_it_seek\n\n\nSeek to a provided frame. Seek should work such that a successive call to\n\nnext\n returns the frame at the index provided to seek.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_media_it_seek(JaniceMediaIterator it,\n                                               uint32_t frame);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator\n\n\nA media iterator object to seek in\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nThe frame to seek to. It must be less than the total number of frames in the video.\n\n\n\n\n\n\n\n\njanice_media_it_get\n\n\nGet a specified frame from a media object. This method should be functionally\nequivalent to calling \njanice_media_it_seek(frame)\n followed by\n\njanice_media_it_next(image)\n.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_media_it_get(JaniceMediaIterator it,\n                                              JaniceImage* image,\n                                              uint32_t frame);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator\n\n\nA media iterator object to get a frame from\n\n\n\n\n\n\nimage\n\n\nJaniceImage*\n\n\nAn uninitialized image object to hold the frame or image\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nThe index of the frame to get. This must be less than the number of frames in the video.\n\n\n\n\n\n\n\n\njanice_media_it_tell\n\n\nGet the current frame position of a media object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_media_it_tell(JaniceMediaIterator it,\n                                               uint32_t* frame);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator\n\n\nA media object to get the current frame position from\n\n\n\n\n\n\nframe\n\n\nuint32_t*\n\n\nA container to hold the queried frame value\n\n\n\n\n\n\n\n\njanice_free_media_iterator\n\n\nFree any memory associated with a \nJaniceMediaIterator\n.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_media_iterator(JaniceMediaIterator* it);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator*\n\n\nAn iterator object to free\n\n\n\n\n\n\n\n\njanice_create_media\n\n\nCreate a media object from a file\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_media(const char* filename,\n                                              JaniceMedia* media);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nA path to a file on disk\n\n\n\n\n\n\nmedia\n\n\nJaniceMedia*\n\n\nAn uninitialized pointer to a media object\n\n\n\n\n\n\n\n\njanice_media_get_iterator\n\n\nGet an iterator from a media object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_media_get_iterator(JaniceConstMedia media,\n                                                    JaniceMediaIterator* it);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceConstMedia\n\n\nA media object to get an iterator from\n\n\n\n\n\n\nit\n\n\nJaniceMediaIterator*\n\n\nAn uninitialized iterator object.\n\n\n\n\n\n\n\n\njanice_free_media\n\n\nFree any memory associated with a \nJaniceMedia\n.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_media(JaniceMedia* media);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceMedia*\n\n\nA media object to free", 
            "title": "Functions"
        }, 
        {
            "location": "/api/io/functions/#JaniceImageAccess", 
            "text": "Get a pixel value at a given row, column and channel.", 
            "title": "janice_image_access"
        }, 
        {
            "location": "/api/io/functions/#JaniceImageAccessSignature", 
            "text": "JANICE_EXPORT JaniceError janice_image_access(JaniceConstImage image,\n                                              uint32_t channel,\n                                              uint32_t row,\n                                              uint32_t col,\n                                              uint8_t* value);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceImageAccessThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceImageAccessParameters", 
            "text": "Name  Type  Description      image  JaniceConstImage  An image object    channel  uint32_t  The channel to access. Must be less than image- channels.    row  uint32_t  The row to access. Must be less than image- rows.    col  uint32_t  The column to access. Must be less that image- cols.    value  uint8_t*  A container for the value at the given index.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeImage", 
            "text": "Free any memory associated with a  JaniceImage .", 
            "title": "janice_free_image"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeImageSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_image(JaniceImage* image);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeImageThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeImageParameters", 
            "text": "Name  Type  Description      image  JaniceImage*  An image object to free", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItNext", 
            "text": "Get the next frame or load the image from a media iterator.", 
            "title": "janice_media_it_next"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItNextSignature", 
            "text": "JANICE_EXPORT JaniceError janice_media_it_next(JaniceMediaIterator it,\n                                               JaniceImage* image);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItNextThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItNextParameters", 
            "text": "Name  Type  Description      it  JaniceMediaIterator  A media iterator object to query    image  JaniceImage*  An uninitialized pointer to an image object to hold the next frame or image", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItSeek", 
            "text": "Seek to a provided frame. Seek should work such that a successive call to next  returns the frame at the index provided to seek.", 
            "title": "janice_media_it_seek"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItSeekSignature", 
            "text": "JANICE_EXPORT JaniceError janice_media_it_seek(JaniceMediaIterator it,\n                                               uint32_t frame);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItSeekThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItSeekParameters", 
            "text": "Name  Type  Description      it  JaniceMediaIterator  A media iterator object to seek in    frame  uint32_t  The frame to seek to. It must be less than the total number of frames in the video.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItGet", 
            "text": "Get a specified frame from a media object. This method should be functionally\nequivalent to calling  janice_media_it_seek(frame)  followed by janice_media_it_next(image) .", 
            "title": "janice_media_it_get"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItGetSignature", 
            "text": "JANICE_EXPORT JaniceError janice_media_it_get(JaniceMediaIterator it,\n                                              JaniceImage* image,\n                                              uint32_t frame);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItGetThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItGetParameters", 
            "text": "Name  Type  Description      it  JaniceMediaIterator  A media iterator object to get a frame from    image  JaniceImage*  An uninitialized image object to hold the frame or image    frame  uint32_t  The index of the frame to get. This must be less than the number of frames in the video.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItTell", 
            "text": "Get the current frame position of a media object.", 
            "title": "janice_media_it_tell"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItTellSignature", 
            "text": "JANICE_EXPORT JaniceError janice_media_it_tell(JaniceMediaIterator it,\n                                               uint32_t* frame);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItTellThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaItTellParameters", 
            "text": "Name  Type  Description      it  JaniceMediaIterator  A media object to get the current frame position from    frame  uint32_t*  A container to hold the queried frame value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaIterator", 
            "text": "Free any memory associated with a  JaniceMediaIterator .", 
            "title": "janice_free_media_iterator"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaIteratorSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_media_iterator(JaniceMediaIterator* it);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaIteratorThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaIteratorParameters", 
            "text": "Name  Type  Description      it  JaniceMediaIterator*  An iterator object to free", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceCreateMedia", 
            "text": "Create a media object from a file", 
            "title": "janice_create_media"
        }, 
        {
            "location": "/api/io/functions/#JaniceCreateMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_media(const char* filename,\n                                              JaniceMedia* media);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceCreateMediaThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceCreateMediaParameters", 
            "text": "Name  Type  Description      filename  const char*  A path to a file on disk    media  JaniceMedia*  An uninitialized pointer to a media object", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaGetIterator", 
            "text": "Get an iterator from a media object.", 
            "title": "janice_media_get_iterator"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaGetIteratorSignature", 
            "text": "JANICE_EXPORT JaniceError janice_media_get_iterator(JaniceConstMedia media,\n                                                    JaniceMediaIterator* it);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaGetIteratorThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceMediaGetIteratorParameters", 
            "text": "Name  Type  Description      media  JaniceConstMedia  A media object to get an iterator from    it  JaniceMediaIterator*  An uninitialized iterator object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMedia", 
            "text": "Free any memory associated with a  JaniceMedia .", 
            "title": "janice_free_media"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_media(JaniceMedia* media);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaThreadSafety", 
            "text": "This function is reentrant", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/io/functions/#JaniceFreeMediaParameters", 
            "text": "Name  Type  Description      media  JaniceMedia*  A media object to free", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/overview/", 
            "text": "In the context of this API, detection is used to refer to the identification of\nobjects of interest within a \nmedia\n object. Detections are\nrepresented using the \nJaniceDetectionType\n\nobject which implementors are free to define however they would like. For\nimages, a detection is defined as a rectangle that bounds an object of interest\nand an associated confidence value. For video, a single object can exist in\nmultiple frames. A rectangle and confidence are only relevant in a single\nframe. In this case, we define a detection as a list of (rectangle, confidence)\npairs that track a single object through a video. It is not required that this\nlist be dense however (i.e. frames can be skipped). To support this, we extend\nour representation of a detection to a (rectangle,confidence,frame) tuple where\nframe gives the index of the frame the rectangle was found in.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/detection/structs/", 
            "text": "JaniceRect\n\n\nA simple struct that represents a rectangle\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx\n\n\nuint32_t\n\n\nThe x offset of the rectangle in pixels\n\n\n\n\n\n\ny\n\n\nuint32_t\n\n\nThe y offset of the rectangle in pixels\n\n\n\n\n\n\nwidth\n\n\nuint32_t\n\n\nThe width of the rectangle in pixels\n\n\n\n\n\n\nheight\n\n\nuint32_t\n\n\nThe height of the rectangle in pixels\n\n\n\n\n\n\n\n\nJaniceDetectionIteratorType\n\n\nAn opaque pointer to an iterator class through a detection. If the detection\nwas computed from an image, the iterator should only move over a single value.\nIf the detection was computed from a video, the iterator should move over an\narray of elements, the length of which is less than or equal to the number of\nframes in the video, and might be sparse (i.e. frames can be skipped).\n\n\nJaniceDetectionType\n\n\nAn opaque pointer to a struct that represents a detection. See\n\nthe detection overview\n for more information.", 
            "title": "Structs"
        }, 
        {
            "location": "/api/detection/structs/#JaniceRect", 
            "text": "A simple struct that represents a rectangle", 
            "title": "JaniceRect"
        }, 
        {
            "location": "/api/detection/structs/#JaniceRectFields", 
            "text": "Name  Type  Description      x  uint32_t  The x offset of the rectangle in pixels    y  uint32_t  The y offset of the rectangle in pixels    width  uint32_t  The width of the rectangle in pixels    height  uint32_t  The height of the rectangle in pixels", 
            "title": "Fields"
        }, 
        {
            "location": "/api/detection/structs/#JaniceDetectionIteratorType", 
            "text": "An opaque pointer to an iterator class through a detection. If the detection\nwas computed from an image, the iterator should only move over a single value.\nIf the detection was computed from a video, the iterator should move over an\narray of elements, the length of which is less than or equal to the number of\nframes in the video, and might be sparse (i.e. frames can be skipped).", 
            "title": "JaniceDetectionIteratorType"
        }, 
        {
            "location": "/api/detection/structs/#JaniceDetectionType", 
            "text": "An opaque pointer to a struct that represents a detection. See the detection overview  for more information.", 
            "title": "JaniceDetectionType"
        }, 
        {
            "location": "/api/detection/typedefs/", 
            "text": "JaniceDetectionIterator\n\n\nA pointer to a \nJaniceDetectionIteratorType\n object.\n\n\nSignature\n\n\ntypedef struct JaniceDetectionIteratorType* JaniceDetectionIterator;\n\n\n\n\nJaniceDetection\n\n\nA pointer to a \nJaniceDetectionType\n object.\n\n\nSignature\n\n\ntypedef struct JaniceDetectionType* JaniceDetection;\n\n\n\n\nJaniceConstDetection\n\n\nA pointer to a constant \nJaniceDetectionType\n object.\n\n\nSignature\n\n\ntypedef const struct JaniceDetectionType* JaniceConstDetection;\n\n\n\n\nJaniceDetections\n\n\nAn array of \nJaniceDetection\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceDetection* JaniceDetections;\n\n\n\n\nJaniceConstDetections\n\n\nAn array of \nJaniceConstDetection\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceConstDetection* JaniceConstDetections;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/detection/typedefs/#janicedetectioniterator", 
            "text": "A pointer to a  JaniceDetectionIteratorType  object.", 
            "title": "JaniceDetectionIterator"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceDetectionIterator", 
            "text": "typedef struct JaniceDetectionIteratorType* JaniceDetectionIterator;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceDetection", 
            "text": "A pointer to a  JaniceDetectionType  object.", 
            "title": "JaniceDetection"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceDetectionSignature", 
            "text": "typedef struct JaniceDetectionType* JaniceDetection;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceConstDetection", 
            "text": "A pointer to a constant  JaniceDetectionType  object.", 
            "title": "JaniceConstDetection"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceConstDetectionSignature", 
            "text": "typedef const struct JaniceDetectionType* JaniceConstDetection;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceDetections", 
            "text": "An array of  JaniceDetection  objects.", 
            "title": "JaniceDetections"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceDetectionsSignature", 
            "text": "typedef struct JaniceDetection* JaniceDetections;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceConstDetections", 
            "text": "An array of  JaniceConstDetection  objects.", 
            "title": "JaniceConstDetections"
        }, 
        {
            "location": "/api/detection/typedefs/#JaniceConstDetectionsSignature", 
            "text": "typedef struct JaniceConstDetection* JaniceConstDetections;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/", 
            "text": "janice_detection_it_next\n\n\nGet the next element in a detection track.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_detection_it_next(JaniceDetectionIterator it,\n                                                   JaniceRect* rect,\n                                                   uint32_t* frame,\n                                                   float* confidence);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nConfidence\n\n\nThe confidence value indicates a likelihood that the rectangle actually bounds\nan object of interest. It is \nNOT\n required to be a probability and often\nonly has meaning relative to other confidence values from the same algorithm.\nThe only restriction is that a larger confidence value indicates a greater\nlikelihood that the rectangle bounds an object.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceDetectionIterator\n\n\nA detection iterator object\n\n\n\n\n\n\nrect\n\n\nJaniceRect*\n\n\nThe location of a object of interest\n\n\n\n\n\n\nframe\n\n\n[uint32_t*]\n\n\nThe frame index for an object of interest.\n\n\n\n\n\n\nconfidence\n\n\n[float*]\n\n\nThe \nconfidence\n of the location.\n\n\n\n\n\n\n\n\njanice_detection_it_reset\n\n\nReset an iterator back to its initial state.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_detection_it_reset(JaniceDetectionIterator it);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceDetectionIterator\n\n\nThe iterator object to reset.\n\n\n\n\n\n\n\n\njanice_free_detection_it\n\n\nFree any memory associated with a detection iterator object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_detection_it(JaniceDetectionIterator* it);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nit\n\n\nJaniceDetectionIterator*\n\n\nThe iterator object to free.\n\n\n\n\n\n\n\n\njanice_create_detection\n\n\nCreate a detection from a known rectangle. This is useful if a human has\nidentified an object of interest and would like to run subsequent API\nfunctions on it. In the case where the input media is a video the given\nrectangle is considered an initial sighting of the object of interest. The\nimplementation may detect additional sightings of the object in successive\nframes.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_detection(JaniceConstMedia media,\n                                                  const JaniceRect rect,\n                                                  uint32_t frame,\n                                                  JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nFace Recognition\n\n\nThe provided rectangle will encapsulate a face in the media.\n\n\nCamera Identification\n\n\nThe provided rectangle will encapsulate a region of interest in the media. Often the\nrectangle will simply border the entire image. Note that at this time camera\nidentification is only implemented for images and will return an error if the\nmedia is a video. Because the implementation is image-only the value in the\nframe parameter is ignored.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceConstMedia\n\n\nA media object to create the detection from\n\n\n\n\n\n\nrect\n\n\nconst \nJaniceRect\n\n\nA rectangle that bounds the object of interest\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nAn index to the frame in the media the rectangle refers to. If the media is an image this should be 0.\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized pointer to a detection object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media; // Where media is a valid media object created previously\n\nJaniceRect rect; // Create a bounding rectangle around an object of interest\nrect.x      = 10; // The rectangle should fall within the bounds of the media\nrect.y      = 10; // This code assumes media width \n 110 and media height \n 110\nrect.width  = 100;\nrect.height = 100;\n\nJaniceDetection detection = NULL; // best practice to initialize to NULL\nif (janice_create_detection(media, rect, 0 /* frame */, \ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_detect\n\n\nAutomatically detect objects in a media object. See\n\nthe detection overview\n for an overview of detection in the\ncontext of this API.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_detect(JaniceConstMedia media,\n                                        uint32_t min_object_size,\n                                        JaniceDetections* detections,\n                                        uint32_t* num_detections);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nMinimum Object Size\n\n\nThis function specifies a minimum object size as one of its parameters. This\nvalue indicates the minimum size of objects that the user would like to see\ndetected. Often, increasing the minimum size can improve runtime of algorithms.\nThe size is in pixels and corresponds to the length of the smaller side of the\nrectangle. This means a detection will be returned if and only if its smaller\nside is larger than the value specified. If the user does not wish to specify a\nminimum width 0 can be provided.\n\n\nTracking\n\n\nWhen the input media is a video many implementations will implement a form of\nobject tracking to correlate multiple sightings of the same object into a\nsingle structure. There are a number of approaches and algorithms to implement\nobject tracking. This API makes NO attempt to define or otherwise constrain how\nimplementations handle tracking. Users should be warned that an implementation\nmight output multiple tracks for a single object and that a single track might\ncontain multiple objects in it by mistake. In some cases, which should be\nclearly documented in implementation documentation, it might be beneficial to\nperform a post-processing clustering step on the results tracks, which could\nhelp correlate multiple tracks of the same object.\n\n\nFace Recognition\n\n\nThis function detects faces in the media.\n\n\nCamera Identification\n\n\nThis function provides a list of size 1 where the only entry is a detection\nwith a rect that encapsulates the entire image.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmedia\n\n\nJaniceConstMedia\n\n\nA media object to create the detection from.\n\n\n\n\n\n\nmin_object_size\n\n\nuint32_t\n\n\nA minimum object size. See \nMinimum Object Size\n\n\n\n\n\n\ndetections\n\n\nJaniceDetections*\n\n\nAn uninitialized array to hold all of the detections detected in the media object.\n\n\n\n\n\n\nnum_detections\n\n\nuint32_t*\n\n\nThe number of detections detected\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceMedia media; // Where media is a valid media object created previously\nconst uint32_t min_object_size = 24; // Only find objects where the smaller\n                                     // side is \n 24 pixels\nJaniceDetection* detections = NULL; // best practice to initialize to NULL\nuint32_t num_detections; // Will be populated with the size of detections\n\nif (janice_detect(media, min_object_size, \ndetections, \nnum_detections) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_create_detection_it\n\n\nCreate an iterator to iterate over detection elements.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_detection_it(JaniceConstDetection detection,\n                                                     JaniceDetectionIterator* it);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nThe detection to create the iterator from.\n\n\n\n\n\n\nit\n\n\nJaniceDetectionIterator*\n\n\nAn uninitialized detection iterator object. It is initialized as part of the function call.\n\n\n\n\n\n\n\n\njanice_serialize_detection\n\n\nSerialize a \nJaniceDetection\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_detection(JaniceConstDetection detection,\n                                                     JaniceBuffer* data,\n                                                     size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nA detection object to serialize\n\n\n\n\n\n\ndata\n\n\nJaniceBuffer*\n\n\nAn uninitialized buffer to hold the flattened data.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_detection\n\n\nDeserialize a \nJaniceDetection\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_detection(const JaniceBuffer data,\n                                                       size_t len,\n                                                       JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nJaniceBuffer\n\n\nA buffer containing data from a flattened detection object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized detection object.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.detection\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);\n\n\n\n\njanice_read_detection\n\n\nRead a detection from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.detection\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_detection(const char* filename,\n                                                JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nAn uninitialized detection object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection = NULL;\nif (janice_read_detection(\nexample.detection\n, \ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_detection\n\n\nWrite a detection to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.detection\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_detection(JaniceConstDetection detection,\n                                                 const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceConstDetection\n\n\nThe detection object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection created\n                           // previously\nif (janice_write_detection(detection, \nexample.detection\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_detection\n\n\nFree any memory associated with a \nJaniceDetectionType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_detection(JaniceDetection* detection);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetection\n\n\nJaniceDetection*\n\n\nA detection object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nif (janice_free_detection(\ndetection) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_detections\n\n\nFree any memory associated with an array of\n\nJaniceDetection\n objects. This function should\nfree memory allocated for the underlying detection objects AND memory allocated\nfor the array.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_detections(JaniceDetections* detection,\n                                                 uint32_t num_detections);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetections\n\n\nJaniceDetections*\n\n\nAn array of detections to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.", 
            "title": "Functions"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItNext", 
            "text": "Get the next element in a detection track.", 
            "title": "janice_detection_it_next"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItNextSignature", 
            "text": "JANICE_EXPORT JaniceError janice_detection_it_next(JaniceDetectionIterator it,\n                                                   JaniceRect* rect,\n                                                   uint32_t* frame,\n                                                   float* confidence);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItNextThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItNextConfidence", 
            "text": "The confidence value indicates a likelihood that the rectangle actually bounds\nan object of interest. It is  NOT  required to be a probability and often\nonly has meaning relative to other confidence values from the same algorithm.\nThe only restriction is that a larger confidence value indicates a greater\nlikelihood that the rectangle bounds an object.", 
            "title": "Confidence"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItNextParameters", 
            "text": "Name  Type  Description      it  JaniceDetectionIterator  A detection iterator object    rect  JaniceRect*  The location of a object of interest    frame  [uint32_t*]  The frame index for an object of interest.    confidence  [float*]  The  confidence  of the location.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItReset", 
            "text": "Reset an iterator back to its initial state.", 
            "title": "janice_detection_it_reset"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItResetSignature", 
            "text": "JANICE_EXPORT JaniceError janice_detection_it_reset(JaniceDetectionIterator it);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItResetThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectionItResetParameters", 
            "text": "Name  Type  Description      it  JaniceDetectionIterator  The iterator object to reset.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionIt", 
            "text": "Free any memory associated with a detection iterator object.", 
            "title": "janice_free_detection_it"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionItSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_detection_it(JaniceDetectionIterator* it);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionItThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionItParameters", 
            "text": "Name  Type  Description      it  JaniceDetectionIterator*  The iterator object to free.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetection", 
            "text": "Create a detection from a known rectangle. This is useful if a human has\nidentified an object of interest and would like to run subsequent API\nfunctions on it. In the case where the input media is a video the given\nrectangle is considered an initial sighting of the object of interest. The\nimplementation may detect additional sightings of the object in successive\nframes.", 
            "title": "janice_create_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_detection(JaniceConstMedia media,\n                                                  const JaniceRect rect,\n                                                  uint32_t frame,\n                                                  JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionFaceRecognition", 
            "text": "The provided rectangle will encapsulate a face in the media.", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionCameraIdentification", 
            "text": "The provided rectangle will encapsulate a region of interest in the media. Often the\nrectangle will simply border the entire image. Note that at this time camera\nidentification is only implemented for images and will return an error if the\nmedia is a video. Because the implementation is image-only the value in the\nframe parameter is ignored.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionParameters", 
            "text": "Name  Type  Description      media  JaniceConstMedia  A media object to create the detection from    rect  const  JaniceRect  A rectangle that bounds the object of interest    frame  uint32_t  An index to the frame in the media the rectangle refers to. If the media is an image this should be 0.    detection  JaniceDetection*  An uninitialized pointer to a detection object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionExample", 
            "text": "JaniceMedia media; // Where media is a valid media object created previously\n\nJaniceRect rect; // Create a bounding rectangle around an object of interest\nrect.x      = 10; // The rectangle should fall within the bounds of the media\nrect.y      = 10; // This code assumes media width   110 and media height   110\nrect.width  = 100;\nrect.height = 100;\n\nJaniceDetection detection = NULL; // best practice to initialize to NULL\nif (janice_create_detection(media, rect, 0 /* frame */,  detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetect", 
            "text": "Automatically detect objects in a media object. See the detection overview  for an overview of detection in the\ncontext of this API.", 
            "title": "janice_detect"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectSignature", 
            "text": "JANICE_EXPORT JaniceError janice_detect(JaniceConstMedia media,\n                                        uint32_t min_object_size,\n                                        JaniceDetections* detections,\n                                        uint32_t* num_detections);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectMinimumObjectSize", 
            "text": "This function specifies a minimum object size as one of its parameters. This\nvalue indicates the minimum size of objects that the user would like to see\ndetected. Often, increasing the minimum size can improve runtime of algorithms.\nThe size is in pixels and corresponds to the length of the smaller side of the\nrectangle. This means a detection will be returned if and only if its smaller\nside is larger than the value specified. If the user does not wish to specify a\nminimum width 0 can be provided.", 
            "title": "Minimum Object Size"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectTracking", 
            "text": "When the input media is a video many implementations will implement a form of\nobject tracking to correlate multiple sightings of the same object into a\nsingle structure. There are a number of approaches and algorithms to implement\nobject tracking. This API makes NO attempt to define or otherwise constrain how\nimplementations handle tracking. Users should be warned that an implementation\nmight output multiple tracks for a single object and that a single track might\ncontain multiple objects in it by mistake. In some cases, which should be\nclearly documented in implementation documentation, it might be beneficial to\nperform a post-processing clustering step on the results tracks, which could\nhelp correlate multiple tracks of the same object.", 
            "title": "Tracking"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectFaceRecognition", 
            "text": "This function detects faces in the media.", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectCameraIdentification", 
            "text": "This function provides a list of size 1 where the only entry is a detection\nwith a rect that encapsulates the entire image.", 
            "title": "Camera Identification"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectParameters", 
            "text": "Name  Type  Description      media  JaniceConstMedia  A media object to create the detection from.    min_object_size  uint32_t  A minimum object size. See  Minimum Object Size    detections  JaniceDetections*  An uninitialized array to hold all of the detections detected in the media object.    num_detections  uint32_t*  The number of detections detected", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDetectExample", 
            "text": "JaniceMedia media; // Where media is a valid media object created previously\nconst uint32_t min_object_size = 24; // Only find objects where the smaller\n                                     // side is   24 pixels\nJaniceDetection* detections = NULL; // best practice to initialize to NULL\nuint32_t num_detections; // Will be populated with the size of detections\n\nif (janice_detect(media, min_object_size,  detections,  num_detections) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionIt", 
            "text": "Create an iterator to iterate over detection elements.", 
            "title": "janice_create_detection_it"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionItSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_detection_it(JaniceConstDetection detection,\n                                                     JaniceDetectionIterator* it);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionItThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceCreateDetectionItParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  The detection to create the iterator from.    it  JaniceDetectionIterator*  An uninitialized detection iterator object. It is initialized as part of the function call.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceSerializeDetection", 
            "text": "Serialize a  JaniceDetection  object to a flat buffer.", 
            "title": "janice_serialize_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceSerializeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_detection(JaniceConstDetection detection,\n                                                     JaniceBuffer* data,\n                                                     size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceSerializeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceSerializeDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  A detection object to serialize    data  JaniceBuffer*  An uninitialized buffer to hold the flattened data.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceSerializeDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDeserializeDetection", 
            "text": "Deserialize a  JaniceDetection  object from a flat buffer.", 
            "title": "janice_deserialize_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDeserializeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_detection(const JaniceBuffer data,\n                                                       size_t len,\n                                                       JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceDeserializeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#parameters", 
            "text": "Name  Type  Description      data  const  JaniceBuffer  A buffer containing data from a flattened detection object.    len  size_t  The length of the flat buffer    detection  JaniceDetection*  An uninitialized detection object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#example", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen( serialized.detection ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceReadDetection", 
            "text": "Read a detection from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen( serialized.detection ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceDetection detection = nullptr;\njanice_deserialize_detection(buffer, buffer_len, detection);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceReadDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_detection(const char* filename,\n                                                JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceReadDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceReadDetectionParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    detection  JaniceDetection*  An uninitialized detection object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceReadDetectionExample", 
            "text": "JaniceDetection detection = NULL;\nif (janice_read_detection( example.detection ,  detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceWriteDetection", 
            "text": "Write a detection to a file on disk. This method is functionally equivalent\nto the following-  JaniceDetection detection; // Where detection is a valid detection created\n                           // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_detection(detection,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.detection ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceWriteDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_detection(JaniceConstDetection detection,\n                                                 const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceWriteDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceWriteDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceConstDetection  The detection object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceWriteDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection created\n                           // previously\nif (janice_write_detection(detection,  example.detection ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetection", 
            "text": "Free any memory associated with a  JaniceDetectionType  object.", 
            "title": "janice_free_detection"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_detection(JaniceDetection* detection);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionParameters", 
            "text": "Name  Type  Description      detection  JaniceDetection*  A detection object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionExample", 
            "text": "JaniceDetection detection; // Where detection is a valid detection object\n                           // created previously\nif (janice_free_detection( detection) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetections", 
            "text": "Free any memory associated with an array of JaniceDetection  objects. This function should\nfree memory allocated for the underlying detection objects AND memory allocated\nfor the array.", 
            "title": "janice_free_detections"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionsSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_detections(JaniceDetections* detection,\n                                                 uint32_t num_detections);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionsThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/detection/functions/#JaniceFreeDetectionsParameters", 
            "text": "Name  Type  Description      detections  JaniceDetections*  An array of detections to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/overview/", 
            "text": "This API defines feature extraction as the process of turning 1 or more\n\ndetections\n that refer to the same object into a single\nrepresentation. This representation is defined in the API using the\n\nJaniceTemplateType\n object. In some cases (e.g.\nface recognition) this model of [multiple detections] -\n [single\nrepresentation] contradicts the current paradigm of [single detection] -\n\n[single representation]. Implementors are free to implement whatever paradigm\nthey choose internally (i.e. a JanICE template could be a simple list of single\ndetection templates) provided the \ncomparison\n\nfunctions work appropriately.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/enrollment/enums/", 
            "text": "JaniceEnrollmentType\n\n\nOften times, the templates produced by algorithms will require different data for different use cases. The enrollment type indicates what the use case for the created template will be, allowing implementors to specialize their templates if they so desire. The use cases supported by the API are:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nJanice11Reference\n\n\nThe template will be used as a reference template for 1 to 1 verification.\n\n\n\n\n\n\nJanice11Verification\n\n\nThe template will be used for verification against a reference template in 1 to 1 verification.\n\n\n\n\n\n\nJanice1NProbe\n\n\nThe template will be used as a probe in 1 to N search.\n\n\n\n\n\n\nJanice1NGallery\n\n\nThe template will be enrolled into a gallery and searched against for 1 to N search.\n\n\n\n\n\n\nJaniceCluster\n\n\nThe template will be used for clustering", 
            "title": "Enums"
        }, 
        {
            "location": "/api/enrollment/enums/#JaniceEnrollmentType", 
            "text": "Often times, the templates produced by algorithms will require different data for different use cases. The enrollment type indicates what the use case for the created template will be, allowing implementors to specialize their templates if they so desire. The use cases supported by the API are:     Type  Description      Janice11Reference  The template will be used as a reference template for 1 to 1 verification.    Janice11Verification  The template will be used for verification against a reference template in 1 to 1 verification.    Janice1NProbe  The template will be used as a probe in 1 to N search.    Janice1NGallery  The template will be enrolled into a gallery and searched against for 1 to N search.    JaniceCluster  The template will be used for clustering", 
            "title": "JaniceEnrollmentType"
        }, 
        {
            "location": "/api/enrollment/structs/", 
            "text": "JaniceTemplateType\n\n\nAn opaque pointer to a struct that represents a template. See\n\nthe enrollment on overview\n for more information.", 
            "title": "Structs"
        }, 
        {
            "location": "/api/enrollment/structs/#JaniceTemplateType", 
            "text": "An opaque pointer to a struct that represents a template. See the enrollment on overview  for more information.", 
            "title": "JaniceTemplateType"
        }, 
        {
            "location": "/api/enrollment/typedefs/", 
            "text": "JaniceTemplate\n\n\nA pointer to a \nJaniceTemplateType\n object.\n\n\nSignature\n\n\ntypedef struct JaniceTemplateType* JaniceTemplate;\n\n\n\n\nJaniceConstTemplate\n\n\nA pointer to a constant \nJaniceTemplateType\n object.\n\n\nSignature\n\n\ntypedef const struct JaniceTemplateType* JaniceConstTemplate;\n\n\n\n\nJaniceTemplates\n\n\nAn array of \nJaniceTemplate\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceTemplate* JaniceTemplates;\n\n\n\n\nJaniceConstTemplates\n\n\nAn array of \nJaniceConstTemplate\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceConstTemplate* JaniceConstTemplates;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceTemplate", 
            "text": "A pointer to a  JaniceTemplateType  object.", 
            "title": "JaniceTemplate"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceTemplateSignature", 
            "text": "typedef struct JaniceTemplateType* JaniceTemplate;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceConstTemplate", 
            "text": "A pointer to a constant  JaniceTemplateType  object.", 
            "title": "JaniceConstTemplate"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceConstTemplateSignature", 
            "text": "typedef const struct JaniceTemplateType* JaniceConstTemplate;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceTemplates", 
            "text": "An array of  JaniceTemplate  objects.", 
            "title": "JaniceTemplates"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceTemplatesSignature", 
            "text": "typedef struct JaniceTemplate* JaniceTemplates;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceConstTemplates", 
            "text": "An array of  JaniceConstTemplate  objects.", 
            "title": "JaniceConstTemplates"
        }, 
        {
            "location": "/api/enrollment/typedefs/#JaniceConstTemplatesSignature", 
            "text": "typedef struct JaniceConstTemplate* JaniceConstTemplates;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/", 
            "text": "janice_create_template\n\n\nCreate a \nJaniceTemplate\n object from an array of detections.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_template(JaniceConstDetections detections,\n                                                 uint32_t num_detections,\n                                                 JaniceEnrollmentType role,\n                                                 JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetections\n\n\nJaniceConstDetections\n\n\nAn array of detection objects\n\n\n\n\n\n\nnum_detections\n\n\nuint32_t\n\n\nThe number of input detections\n\n\n\n\n\n\nrole\n\n\nJaniceEnrollmentType\n\n\nThe use case for the template\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceDetections detections; // Where detections is a valid array of valid\n                             // detection objects created previously\nconst uint32_t num_detections = K; // Where K is the number of detections in\n                                   // the detections array\nJaniceEnrollmentType role = Janice1NProbe; // This template will be used as a\n                                           // probe in 1-N search\nJaniceTemplate tmpl = NULL; // Best practice to initialize to NULL\n\nif (janice_create_template(detections, num_detections, rolw, \ntmpl) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_template_get_attribute\n\n\nGet a metadata value from a template using a key string. The valid set of keys\nis determined by the implementation and must be included in their delivered\ndocumentation. The possible return values for a valid key are also\nimplementation specific. Invalid keys should return an error.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_template_get_attribute(JaniceConstTemplate tmpl,\n                                                        const char* attribute,\n                                                        char** value);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nA template object to query the attribute from\n\n\n\n\n\n\nattribute\n\n\nconst char*\n\n\nThe name of the attribute to query\n\n\n\n\n\n\nvalue\n\n\nchar**\n\n\nAn uninitialized pointer to hold the attribute value. The return value must be null-terminated.\n\n\n\n\n\n\n\n\njanice_serialize_template\n\n\nSerialize a \nJaniceTemplate\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_template(JaniceConstTemplate tmpl,\n                                                    JaniceBuffer* data,\n                                                    size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nA template object to serialize\n\n\n\n\n\n\ndata\n\n\nJaniceBuffer*\n\n\nAn uninitialized buffer to hold the flattened data.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_template\n\n\nDeserialize a \nJaniceTemplate\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_template(const JaniceBuffer data,\n                                                      size_t len,\n                                                      JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nJaniceBuffer\n\n\nA buffer containing data from a flattened template object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.template\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = NULL; // best practice to initialize to NULL\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);\n\n\n\n\njanice_read_template\n\n\nRead a template from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.template\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = nullptr;\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_template(const char* filename,\n                                               JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nAn uninitialized template object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl = NULL;\nif (janice_read_template(\nexample.template\n, \ntmpl) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_template\n\n\nWrite a template to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.template\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_template(JaniceConstTemplate tmpl,\n                                                const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nThe template object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously\nif (janice_write_template(tmpl, \nexample.template\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_template\n\n\nFree any memory associated with a \nJaniceTemplateType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_template(JaniceTemplate* tmpl);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nJaniceTemplate*\n\n\nA template object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created previously\nif (janice_free_template(\ntmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Functions"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceCreateTemplate", 
            "text": "Create a  JaniceTemplate  object from an array of detections.", 
            "title": "janice_create_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceCreateTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_template(JaniceConstDetections detections,\n                                                 uint32_t num_detections,\n                                                 JaniceEnrollmentType role,\n                                                 JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceCreateTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceCreateTemplateParameters", 
            "text": "Name  Type  Description      detections  JaniceConstDetections  An array of detection objects    num_detections  uint32_t  The number of input detections    role  JaniceEnrollmentType  The use case for the template    tmpl  JaniceTemplate*  An uninitialized template object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceCreateTemplateExample", 
            "text": "JaniceDetections detections; // Where detections is a valid array of valid\n                             // detection objects created previously\nconst uint32_t num_detections = K; // Where K is the number of detections in\n                                   // the detections array\nJaniceEnrollmentType role = Janice1NProbe; // This template will be used as a\n                                           // probe in 1-N search\nJaniceTemplate tmpl = NULL; // Best practice to initialize to NULL\n\nif (janice_create_template(detections, num_detections, rolw,  tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceTemplateGetAttribute", 
            "text": "Get a metadata value from a template using a key string. The valid set of keys\nis determined by the implementation and must be included in their delivered\ndocumentation. The possible return values for a valid key are also\nimplementation specific. Invalid keys should return an error.", 
            "title": "janice_template_get_attribute"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceTemplateGetAttributeSignature", 
            "text": "JANICE_EXPORT JaniceError janice_template_get_attribute(JaniceConstTemplate tmpl,\n                                                        const char* attribute,\n                                                        char** value);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceTemplateGetAttributeThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceTemplateGetAttributeParameters", 
            "text": "Name  Type  Description      tmpl  JaniceConstTemplate  A template object to query the attribute from    attribute  const char*  The name of the attribute to query    value  char**  An uninitialized pointer to hold the attribute value. The return value must be null-terminated.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceSerializeTemplate", 
            "text": "Serialize a  JaniceTemplate  object to a flat buffer.", 
            "title": "janice_serialize_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceSerializeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_template(JaniceConstTemplate tmpl,\n                                                    JaniceBuffer* data,\n                                                    size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceSerializeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceSerializeTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceConstTemplate  A template object to serialize    data  JaniceBuffer*  An uninitialized buffer to hold the flattened data.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceSerializeTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceDeserializeTemplate", 
            "text": "Deserialize a  JaniceTemplate  object from a flat buffer.", 
            "title": "janice_deserialize_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceDeserializeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_template(const JaniceBuffer data,\n                                                      size_t len,\n                                                      JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceDeserializeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#parameters", 
            "text": "Name  Type  Description      data  const  JaniceBuffer  A buffer containing data from a flattened template object.    len  size_t  The length of the flat buffer    tmpl  JaniceTemplate*  An uninitialized template object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#example", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen( serialized.template ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = NULL; // best practice to initialize to NULL\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceReadTemplate", 
            "text": "Read a template from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen( serialized.template ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceTemplate tmpl = nullptr;\njanice_deserialize_template(buffer, buffer_len, tmpl);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceReadTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_template(const char* filename,\n                                               JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceReadTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceReadTemplateParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    tmpl  JaniceTemplate*  An uninitialized template object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceReadTemplateExample", 
            "text": "JaniceTemplate tmpl = NULL;\nif (janice_read_template( example.template ,  tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceWriteTemplate", 
            "text": "Write a template to a file on disk. This method is functionally equivalent\nto the following-  JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_template(tmpl,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.template ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceWriteTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_template(JaniceConstTemplate tmpl,\n                                                const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceWriteTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceWriteTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceConstTemplate  The template object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceWriteTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template created\n                     // previously\nif (janice_write_template(tmpl,  example.template ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceFreeTemplate", 
            "text": "Free any memory associated with a  JaniceTemplateType  object.", 
            "title": "janice_free_template"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceFreeTemplateSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_template(JaniceTemplate* tmpl);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceFreeTemplateThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceFreeTemplateParameters", 
            "text": "Name  Type  Description      tmpl  JaniceTemplate*  A template object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/enrollment/functions/#JaniceFreeTemplateExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created previously\nif (janice_free_template( tmpl) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/overview/", 
            "text": "This API defines a gallery object that represents a collection of templates.\nGalleries are useful in the 1-N use case (see\n\nthe section on comparison\n) when a user would like\nto query an unknown probe template against a set of known identities. A naive\nimplementation of a gallery might be a simple array of templates. Often\nhowever, implementations have optimized algorithms or data structures that can\nlead to more efficient search times. It is recommended that advanced data\nstructures be implemented as part of a gallery. Please note however the rules\non gallery modification:\n\n\n\n\nGallery objects may be modified (templates inserted or removed) at any time.\n\n\nIt is understood that some preprocessing might need to be done between\n   gallery modification and efficient search. A function\n   \njanice_prepare_gallery\n exists for this\n   purpose. The calling of this function however is optional. Please see the\n   \ndocumentation\n for more information.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/gallery/structs/", 
            "text": "JaniceGalleryType\n\n\nAn opaque pointer to a struct that represents a gallery. See \nthe paragraph on\ngalleries\n for more information.", 
            "title": "Structs"
        }, 
        {
            "location": "/api/gallery/structs/#JaniceGalleryType", 
            "text": "An opaque pointer to a struct that represents a gallery. See  the paragraph on\ngalleries  for more information.", 
            "title": "JaniceGalleryType"
        }, 
        {
            "location": "/api/gallery/typedefs/", 
            "text": "JaniceGallery\n\n\nA pointer to a \nJaniceGalleryType\n object.\n\n\nSignature\n\n\ntypedef struct JaniceGalleryType* JaniceGallery;\n\n\n\n\nJaniceConstGallery\n\n\nA pointer to a constant \nJaniceGalleryType\n object.\n\n\nSignature\n\n\ntypedef const struct JaniceGalleryType* JaniceConstGallery;\n\n\n\n\nJaniceTemplateId\n\n\nA unique identifier for a template.\n\n\nSignature\n\n\ntypedef uint32_t JaniceTemplateId;\n\n\n\n\nJaniceTemplateIds\n\n\nAn array of \nJaniceTemplateId\n objects.\n\n\nSignature\n\n\ntypedef JaniceTemplateId* JaniceTemplateIds;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceGallery", 
            "text": "A pointer to a  JaniceGalleryType  object.", 
            "title": "JaniceGallery"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceGallerySignature", 
            "text": "typedef struct JaniceGalleryType* JaniceGallery;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceConstGallery", 
            "text": "A pointer to a constant  JaniceGalleryType  object.", 
            "title": "JaniceConstGallery"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceConstGallerySignature", 
            "text": "typedef const struct JaniceGalleryType* JaniceConstGallery;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceTemplateId", 
            "text": "A unique identifier for a template.", 
            "title": "JaniceTemplateId"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceTemplateIdSignature", 
            "text": "typedef uint32_t JaniceTemplateId;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceTemplateIds", 
            "text": "An array of  JaniceTemplateId  objects.", 
            "title": "JaniceTemplateIds"
        }, 
        {
            "location": "/api/gallery/typedefs/#JaniceTemplateIdsSignature", 
            "text": "typedef JaniceTemplateId* JaniceTemplateIds;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/", 
            "text": "janice_create_gallery\n\n\nCreate a \nJaniceGallery\n object from a list of\ntemplates and unique ids.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_create_gallery(JaniceConstTemplates tmpls,\n                                                const JaniceTemplateIds ids,\n                                                uint32_t num_tmpls,\n                                                JaniceGallery* gallery);\n\n\n\n\nThread Safety {: #JaniceCreateGalleryThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpls\n\n\nJaniceConstTemplates\n\n\nAn array of templates to add to the gallery\n\n\n\n\n\n\nids\n\n\nconst \nJaniceTemplateIds\n\n\nA set of unique identifiers to associate with the input templates. The \nith\n id corresponds to the \nith\n input template.\n\n\n\n\n\n\nnum_tmpls\n\n\nuint32_t\n\n\nThe number of templates in the array.\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplates tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nJaniceTemplateIds ids; // Where ids is a valid array of unique unsigned integers that\n                       // is the same length as tmpls\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_insert\n\n\nInsert a template into a gallery object. The template data should be copied\ninto the gallery as the template may be deleted after this function.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_insert(JaniceGallery gallery,\n                                                JaniceConstTemplate tmpl,\n                                                JaniceTemplateId id);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to insert the template into.\n\n\n\n\n\n\ntmpl\n\n\nJaniceConstTemplate\n\n\nA template object to insert into the gallery.\n\n\n\n\n\n\nid\n\n\nJaniceTemplateId\n\n\nA unique id to associate with the input template\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nJaniceTemplateId id; // Where id is a unique integer to associate with tmpl. This\n                     // integer should not exist in the gallery\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\n\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_remove\n\n\nRemove a template from a gallery object using its unique id.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_remove(JaniceGallery gallery,\n                                                uint32_t id);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to remove the template from\n\n\n\n\n\n\nid\n\n\nJaniceTemplateId\n\n\nA unique id associated with a template in the gallery that indicates which template should be remove.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nconst JaniceTemplateId id = 0; // A unique integer id to associate with tmpl.\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously that does not have a template with id '0'\n                       // already inserted in it.\n\n// Insert the template with id 0\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n// Now we can remove the template\nif (janice_gallery_remove(gallery, id) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_gallery_prepare\n\n\nPrepare a gallery for search. Implementors can use this function as an\nopportunity to streamline gallery objects to accelerate the search process. The\ncalling convention for this function is \nNOT\n specified by the API, this\nmeans that this function is not guaranteed to be called before\n\njanice_search\n. It also means that templates can be added\nto a gallery before and after this function is called. Implementations should\nhandle all of these calling conventions. However, users should be aware that\nthis function may be computationally expensive. They should strive to call it\nonly at critical junctions before search and as few times as possible overall.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_gallery_prepare(JaniceGallery gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery\n\n\nA gallery object to prepare\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nJaniceTemplateIds ids; // Where ids is a valid array of unique unsigned integers that\n                       // is the same length as tmpls\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nJaniceTemplateId id; // Where id is a unique integer id to associate with tmpl.\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// It is valid to run search without calling prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare can be called after search\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// Search can be called again right after prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Insert another template into the gallery. This is valid after the gallery\n// has been prepared\nif (janice_gallery_insert(gallery, tmpl, 112) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare the gallery again\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_serialize_gallery\n\n\nSerialize a \nJaniceGallery\n object to a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_serialize_gallery(JaniceConstGallery gallery,\n                                                   JaniceBuffer* data,\n                                                   size_t* len);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nA gallery object to serialize\n\n\n\n\n\n\ndata\n\n\nJaniceBuffer\n\n\nAn uninitialized buffer to hold the flattened data.\n\n\n\n\n\n\nlen\n\n\nsize_t*\n\n\nThe length of the flat buffer after it is filled.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created\n                       // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery, \nbuffer, \nbuffer_len);\n\n\n\n\njanice_deserialize_gallery\n\n\nDeserialize a \nJaniceGallery\n object from a flat buffer.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_deserialize_gallery(const JaniceBuffer data,\n                                                     size_t len,\n                                                     JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nJaniceBuffer\n\n\nA buffer containing data from a flattened gallery object.\n\n\n\n\n\n\nlen\n\n\nsize_t\n\n\nThe length of the flat buffer\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object.\n\n\n\n\n\n\n\n\nExample\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.gallery\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);\n\n\n\n\njanice_read_gallery\n\n\nRead a gallery from a file on disk. This method is functionally equivalent\nto the following-\n\n\nconst size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen(\nserialized.gallery\n, \nr\n);\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when reading from disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_read_gallery(const char* filename,\n                                              JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nAn uninitialized gallery object.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery = NULL;\nif (janice_read_gallery(\nexample.gallery\n, \ngallery) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_write_gallery\n\n\nWrite a gallery to a file on disk. This method is functionally equivalent\nto the following-\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery, \nbuffer, \nbuffer_len);\n\nFILE* file = fopen(\nserialized.gallery\n, \nw+\n);\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);\n\n\n\n\nIt is provided for memory efficiency and ease of use when writing to disk.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_write_gallery(JaniceConstGallery gallery,\n                                               const char* filename);\n\n\n\n\nThreadSafety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nThe gallery object to write to disk\n\n\n\n\n\n\nfilename\n\n\nconst char*\n\n\nThe path to a file on disk\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery created previously\nif (janice_write_gallery(gallery, \nexample.gallery\n) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_free_gallery\n\n\nFree any memory associated with a \nJaniceGalleryType\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_gallery(JaniceGallery* gallery);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nJaniceGallery*\n\n\nA gallery object to free. Best practice dictates the pointer should be set to \nNULL\n after it is freed.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created previously\nif (janice_free_gallery(\ngallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Functions"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceCreateGallery", 
            "text": "Create a  JaniceGallery  object from a list of\ntemplates and unique ids.", 
            "title": "janice_create_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceCreateGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_create_gallery(JaniceConstTemplates tmpls,\n                                                const JaniceTemplateIds ids,\n                                                uint32_t num_tmpls,\n                                                JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#thread-safety-janicecreategallerythreadsafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety {: #JaniceCreateGalleryThreadSafety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceCreateGalleryParameters", 
            "text": "Name  Type  Description      tmpls  JaniceConstTemplates  An array of templates to add to the gallery    ids  const  JaniceTemplateIds  A set of unique identifiers to associate with the input templates. The  ith  id corresponds to the  ith  input template.    num_tmpls  uint32_t  The number of templates in the array.    gallery  JaniceGallery*  An uninitialized gallery object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceCreateGalleryExample", 
            "text": "JaniceTemplates tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nJaniceTemplateIds ids; // Where ids is a valid array of unique unsigned integers that\n                       // is the same length as tmpls\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids,  gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryInsert", 
            "text": "Insert a template into a gallery object. The template data should be copied\ninto the gallery as the template may be deleted after this function.", 
            "title": "janice_gallery_insert"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryInsertSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_insert(JaniceGallery gallery,\n                                                JaniceConstTemplate tmpl,\n                                                JaniceTemplateId id);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryInsertThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryInsertParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to insert the template into.    tmpl  JaniceConstTemplate  A template object to insert into the gallery.    id  JaniceTemplateId  A unique id to associate with the input template", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryInsertExample", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nJaniceTemplateId id; // Where id is a unique integer to associate with tmpl. This\n                     // integer should not exist in the gallery\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\n\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryRemove", 
            "text": "Remove a template from a gallery object using its unique id.", 
            "title": "janice_gallery_remove"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryRemoveSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_remove(JaniceGallery gallery,\n                                                uint32_t id);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryRemoveThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#parameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to remove the template from    id  JaniceTemplateId  A unique id associated with a template in the gallery that indicates which template should be remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#example", 
            "text": "JaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nconst JaniceTemplateId id = 0; // A unique integer id to associate with tmpl.\n\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously that does not have a template with id '0'\n                       // already inserted in it.\n\n// Insert the template with id 0\nif (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)\n    // ERROR!\n\n// Now we can remove the template\nif (janice_gallery_remove(gallery, id) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryPrepare", 
            "text": "Prepare a gallery for search. Implementors can use this function as an\nopportunity to streamline gallery objects to accelerate the search process. The\ncalling convention for this function is  NOT  specified by the API, this\nmeans that this function is not guaranteed to be called before janice_search . It also means that templates can be added\nto a gallery before and after this function is called. Implementations should\nhandle all of these calling conventions. However, users should be aware that\nthis function may be computationally expensive. They should strive to call it\nonly at critical junctions before search and as few times as possible overall.", 
            "title": "janice_gallery_prepare"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryPrepareSignature", 
            "text": "JANICE_EXPORT JaniceError janice_gallery_prepare(JaniceGallery gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryPrepareThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryPrepareParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery  A gallery object to prepare", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceGalleryPrepareExample", 
            "text": "JaniceTemplate* tmpls; // Where tmpls is a valid array of valid template\n                       // objects created previously\nJaniceTemplateIds ids; // Where ids is a valid array of unique unsigned integers that\n                       // is the same length as tmpls\nJaniceTemplate tmpl; // Where tmpl is a valid template object created\n                     // previously\nJaniceTemplateId id; // Where id is a unique integer id to associate with tmpl.\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\n\nif (janice_create_gallery(tmpls, ids,  gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// It is valid to run search without calling prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare can be called after search\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!\n\n// Search can be called again right after prepare\nif (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)\n    // ERROR!\n\n// Insert another template into the gallery. This is valid after the gallery\n// has been prepared\nif (janice_gallery_insert(gallery, tmpl, 112) != JANICE_SUCCESS)\n    // ERROR!\n\n// Prepare the gallery again\nif (janice_gallery_prepare(gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceSerializeGallery", 
            "text": "Serialize a  JaniceGallery  object to a flat buffer.", 
            "title": "janice_serialize_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceSerializeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_serialize_gallery(JaniceConstGallery gallery,\n                                                   JaniceBuffer* data,\n                                                   size_t* len);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceSerializeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceSerializeGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceConstGallery  A gallery object to serialize    data  JaniceBuffer  An uninitialized buffer to hold the flattened data.    len  size_t*  The length of the flat buffer after it is filled.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceSerializeGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery created\n                       // previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery,  buffer,  buffer_len);", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceDeserializeGallery", 
            "text": "Deserialize a  JaniceGallery  object from a flat buffer.", 
            "title": "janice_deserialize_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceDeserializeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_deserialize_gallery(const JaniceBuffer data,\n                                                     size_t len,\n                                                     JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceDeserializeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#parameters_1", 
            "text": "Name  Type  Description      data  const  JaniceBuffer  A buffer containing data from a flattened gallery object.    len  size_t  The length of the flat buffer    gallery  JaniceGallery*  An uninitialized gallery object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#example_1", 
            "text": "const size_t buffer_len = K; // Where K is the known length of the buffer\nunsigned char buffer[buffer_len];\n\nFILE* file = fopen( serialized.gallery ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceReadGallery", 
            "text": "Read a gallery from a file on disk. This method is functionally equivalent\nto the following-  const size_t buffer_len = K; // Where K is the known length of the buffer\nJaniceBuffer buffer[buffer_len];\n\nFILE* file = fopen( serialized.gallery ,  r );\nfread(buffer, 1, buffer_len, file);\n\nJaniceGallery gallery = NULL; // best practice to initialize to NULL\njanice_deserialize_gallery(buffer, buffer_len, gallery);\n\nfclose(file);  It is provided for memory efficiency and ease of use when reading from disk.", 
            "title": "janice_read_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceReadGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_read_gallery(const char* filename,\n                                              JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceReadGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceReadGalleryParameters", 
            "text": "Name  Type  Description      filename  const char*  The path to a file on disk    gallery  JaniceGallery*  An uninitialized gallery object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceReadGalleryExample", 
            "text": "JaniceGallery gallery = NULL;\nif (janice_read_gallery( example.gallery ,  gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceWriteGallery", 
            "text": "Write a gallery to a file on disk. This method is functionally equivalent\nto the following-  JaniceGallery gallery; // Where gallery is a valid gallery created previously.\n\nJaniceBuffer buffer = NULL;\nsize_t buffer_len;\njanice_serialize_gallery(gallery,  buffer,  buffer_len);\n\nFILE* file = fopen( serialized.gallery ,  w+ );\nfwrite(buffer, 1, buffer_len, file);\n\nfclose(file);  It is provided for memory efficiency and ease of use when writing to disk.", 
            "title": "janice_write_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceWriteGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_write_gallery(JaniceConstGallery gallery,\n                                               const char* filename);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceWriteGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "ThreadSafety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceWriteGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceConstGallery  The gallery object to write to disk    filename  const char*  The path to a file on disk", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceWriteGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery created previously\nif (janice_write_gallery(gallery,  example.gallery ) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceFreeGallery", 
            "text": "Free any memory associated with a  JaniceGalleryType  object.", 
            "title": "janice_free_gallery"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceFreeGallerySignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_gallery(JaniceGallery* gallery);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceFreeGalleryThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceFreeGalleryParameters", 
            "text": "Name  Type  Description      gallery  JaniceGallery*  A gallery object to free. Best practice dictates the pointer should be set to  NULL  after it is freed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/gallery/functions/#JaniceFreeGalleryExample", 
            "text": "JaniceGallery gallery; // Where gallery is a valid gallery object created previously\nif (janice_free_gallery( gallery) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/comparison/overview/", 
            "text": "This API defines two possible types of comparisons, 1-1 and 1-many or 1-N.\nThese are represented by the \njanice_verify\n and\n\njanice_search\n functions respectively. The API\nquantified the relationship between two templates as a single number called a\nsimilarity score. The definition of a similarity score in the context of this\nAPI is discussed \nhere\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/comparison/typedefs/", 
            "text": "JaniceSimilarity\n\n\nA number representing the similarity between two templates. See\n[functions.md#JaniceVerifySimilarityScore] for more information.\n\n\nSignature\n\n\ntypedef double JaniceSimilarity\n\n\n\n\nJaniceSearchSimilarities\n\n\nAn array of \nJaniceSimilarity\n objects.\n\n\nSignature\n\n\ntypedef JaniceSimilarity* JaniceSimilarities;\n\n\n\n\nJaniceSearchTemplateIds\n\n\nAn array of \nJaniceTemplateId\n objects.\n\n\nSignature\n\n\ntypedef JaniceTemplateId* JaniceSearchTemplateIds;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSimilarity", 
            "text": "A number representing the similarity between two templates. See\n[functions.md#JaniceVerifySimilarityScore] for more information.", 
            "title": "JaniceSimilarity"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSimilaritySignature", 
            "text": "typedef double JaniceSimilarity", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSimilarities", 
            "text": "An array of  JaniceSimilarity  objects.", 
            "title": "JaniceSearchSimilarities"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSimilaritiesSignature", 
            "text": "typedef JaniceSimilarity* JaniceSimilarities;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSearchTemplateIds", 
            "text": "An array of  JaniceTemplateId  objects.", 
            "title": "JaniceSearchTemplateIds"
        }, 
        {
            "location": "/api/comparison/typedefs/#JaniceSearchTemplateIdsSignature", 
            "text": "typedef JaniceTemplateId* JaniceSearchTemplateIds;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/functions/", 
            "text": "janice_verify\n\n\nCompare two templates with the difference expressed as a similarity score.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_verify(JaniceConstTemplate reference,\n                                        JaniceConstTemplate verification,\n                                        JaniceSimilarity* similarity);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nSimilarity Score\n\n\nThis API expects that the comparison of two templates results in a single value\nthat quantifies the similarity between them. A similarity score is constrained\nby the following requirements:\n\n\n1. Higher scores indicate greater similarity\n2. Scores can be asymmetric. This mean verify(a, b) does not necessarily\n   equal verify(b, a)\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreference\n\n\nJaniceConstTemplate\n\n\nA reference template. This template was created with the \nJanice11Reference\n role.\n\n\n\n\n\n\nverification\n\n\nJaniceConstTemplate\n\n\nA verification template. This template was created with the \nJanice11Verification\n role.\n\n\n\n\n\n\nsimilarity\n\n\nJaniceSimilarity\n*\n\n\nA similarity score. See \nthis section\n for more information.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate reference; // Where reference is a valid template object created\n                          // previously\nJaniceTemplate verification; // Where verification is a valid template object\n                             // created previously\nJaniceSimilarity similarity;\nif (janice_verify(reference, verification, \nsimilarity) != JANICE_SUCCESS)\n    // ERROR!\n\n\n\n\njanice_search\n\n\nCompute 1-N search results between a query template object and a target gallery\nobject. The function allocates two arrays of equal size, one containing\n\nsimilarity scores\n and the other containing the\nunique id of the template the score was computed with (along with the query).\nOften it is desirable (and perhaps computationally efficient) to only see the\ntop K scores out of N possible templates. The option to set a K is provided to\nthe user as part of the function parameters.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_search(JaniceConstTemplate probe,\n                                        JaniceConstGallery gallery,\n                                        uint32_t num_requested,\n                                        JaniceSimilarities* similarities,\n                                        JaniceSearchTemplateIds* ids,\n                                        uint32_t* num_returned);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nprobe\n\n\nJaniceConstTemplate\n\n\nA template object to use as a query\n\n\n\n\n\n\ngallery\n\n\nJaniceConstGallery\n\n\nA gallery object to search against\n\n\n\n\n\n\nnum_requested\n\n\nuint32_t\n\n\nThe number of requested returns. If the user would like as many returns as there are templates in the gallery they can pass this parameter with the value 0.\n\n\n\n\n\n\nsimilarities\n\n\nJaniceSimilarities*\n\n\nAn array of \nsimilarity scores\n. The scores are expected to be sorted in descending order (i.e. the highest scores is stored at index 0).\n\n\n\n\n\n\nids\n\n\nJaniceSearchTemplateIds*\n\n\nAn array of unique ids identifying the target templates associated with the similarity scores. This array must be the same size as the similarities array. The \nith\n id corresponds with the \nith\n similarity.\n\n\n\n\n\n\nnum_returned\n\n\nuint32_t*\n\n\nThe number of elements in the similarities and ids arrays. This number can be different from \nnum_requested\n.\n\n\n\n\n\n\n\n\nExample\n\n\nJaniceTemplate probe;  // Where probe is a valid template object created\n                       // previously\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\nconst uint32_t num_requested = 50; // Request the top 50 matches\n\nJaniceSimilarities similarities = NULL;\nJaniceSearchTemplateIds ids = NULL;\nuint32_t num_returned;\n\n// Run search\nif (janice_search(probe, gallery, num_requested, \nsimilarities, \nids, \nnum_returned) != JANICE_SUCCESS)\n    // ERROR!\n\nnum_requested == num_returned; // This might not be true!\n\n\n\n\njanice_free_similarities\n\n\nFree any memory associated with a \nJaniceSimilarities\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_similarities(JaniceSimilarities* similarities);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsimilarities\n\n\nJaniceSimilarities*\n\n\nAn array of similarities to free.\n\n\n\n\n\n\n\n\njanice_free_search_ids\n\n\nFree any memory associated with a \nJaniceSearchTemplateIds\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_search_ids(JaniceSearchTemplateIds* ids);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nids\n\n\nJaniceSearchTemplateIds*\n\n\nAn array of ids to free.", 
            "title": "Functions"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerify", 
            "text": "Compare two templates with the difference expressed as a similarity score.", 
            "title": "janice_verify"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerifySignature", 
            "text": "JANICE_EXPORT JaniceError janice_verify(JaniceConstTemplate reference,\n                                        JaniceConstTemplate verification,\n                                        JaniceSimilarity* similarity);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerifyThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerifySimilarityScore", 
            "text": "This API expects that the comparison of two templates results in a single value\nthat quantifies the similarity between them. A similarity score is constrained\nby the following requirements:  1. Higher scores indicate greater similarity\n2. Scores can be asymmetric. This mean verify(a, b) does not necessarily\n   equal verify(b, a)", 
            "title": "Similarity Score"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerifyParameters", 
            "text": "Name  Type  Description      reference  JaniceConstTemplate  A reference template. This template was created with the  Janice11Reference  role.    verification  JaniceConstTemplate  A verification template. This template was created with the  Janice11Verification  role.    similarity  JaniceSimilarity *  A similarity score. See  this section  for more information.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceVerifyExample", 
            "text": "JaniceTemplate reference; // Where reference is a valid template object created\n                          // previously\nJaniceTemplate verification; // Where verification is a valid template object\n                             // created previously\nJaniceSimilarity similarity;\nif (janice_verify(reference, verification,  similarity) != JANICE_SUCCESS)\n    // ERROR!", 
            "title": "Example"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceSearch", 
            "text": "Compute 1-N search results between a query template object and a target gallery\nobject. The function allocates two arrays of equal size, one containing similarity scores  and the other containing the\nunique id of the template the score was computed with (along with the query).\nOften it is desirable (and perhaps computationally efficient) to only see the\ntop K scores out of N possible templates. The option to set a K is provided to\nthe user as part of the function parameters.", 
            "title": "janice_search"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceSearchSignature", 
            "text": "JANICE_EXPORT JaniceError janice_search(JaniceConstTemplate probe,\n                                        JaniceConstGallery gallery,\n                                        uint32_t num_requested,\n                                        JaniceSimilarities* similarities,\n                                        JaniceSearchTemplateIds* ids,\n                                        uint32_t* num_returned);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceSearchThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceSearchParameters", 
            "text": "Name  Type  Description      probe  JaniceConstTemplate  A template object to use as a query    gallery  JaniceConstGallery  A gallery object to search against    num_requested  uint32_t  The number of requested returns. If the user would like as many returns as there are templates in the gallery they can pass this parameter with the value 0.    similarities  JaniceSimilarities*  An array of  similarity scores . The scores are expected to be sorted in descending order (i.e. the highest scores is stored at index 0).    ids  JaniceSearchTemplateIds*  An array of unique ids identifying the target templates associated with the similarity scores. This array must be the same size as the similarities array. The  ith  id corresponds with the  ith  similarity.    num_returned  uint32_t*  The number of elements in the similarities and ids arrays. This number can be different from  num_requested .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceSearchExample", 
            "text": "JaniceTemplate probe;  // Where probe is a valid template object created\n                       // previously\nJaniceGallery gallery; // Where gallery is a valid gallery object created\n                       // previously\nconst uint32_t num_requested = 50; // Request the top 50 matches\n\nJaniceSimilarities similarities = NULL;\nJaniceSearchTemplateIds ids = NULL;\nuint32_t num_returned;\n\n// Run search\nif (janice_search(probe, gallery, num_requested,  similarities,  ids,  num_returned) != JANICE_SUCCESS)\n    // ERROR!\n\nnum_requested == num_returned; // This might not be true!", 
            "title": "Example"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSimilarities", 
            "text": "Free any memory associated with a  JaniceSimilarities  object.", 
            "title": "janice_free_similarities"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSimilaritiesSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_similarities(JaniceSimilarities* similarities);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSimilaritiesThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSimilaritiesParameters", 
            "text": "Name  Type  Description      similarities  JaniceSimilarities*  An array of similarities to free.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSearchIds", 
            "text": "Free any memory associated with a  JaniceSearchTemplateIds  object.", 
            "title": "janice_free_search_ids"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSearchIdsSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_search_ids(JaniceSearchTemplateIds* ids);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSearchIdsThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/comparison/functions/#JaniceFreeSearchIdsParamters", 
            "text": "Name  Type  Description      ids  JaniceSearchTemplateIds*  An array of ids to free.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/clustering/overview/", 
            "text": "This API defines clustering is the automatic and unsupervised combination of\nunlabelled templates into groups of like templates. What constitutes likeness\nis heavily dependent on the use case and context in question. One example when\ndealing with faces is grouping based on identity, where all faces belonging to\na single individual are placed in a cluster.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/clustering/structs/", 
            "text": "JaniceMediaClusterItem\n\n\nA structure that connects an input media and location with an output cluster.\nBecause multiple detections could occur in a single piece of media a\n\nJaniceRect\n and a frame index are included\nto identify which detection this item refers to.\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncluster_id\n\n\nJaniceClusterId\n\n\nA unique identifier for the cluster this item belongs to. Items belonging to the same cluster should have the same \ncluster_id\n\n\n\n\n\n\nmedia_id\n\n\nJaniceMediaId\n\n\nA unique identifier for the media object this item corresponds to.\n\n\n\n\n\n\nconfidence\n\n\ndouble\n\n\nThe confidence that this item belongs to this cluster.\n\n\n\n\n\n\nrect\n\n\nJaniceRect\n\n\nThe location of the clustered object in a frame or image.\n\n\n\n\n\n\nframe\n\n\nuint32_t\n\n\nThe frame index of the clustered object if the media is a video, otherwise 0.\n\n\n\n\n\n\n\n\nJaniceTemplateClusterItem\n\n\nA structure that connects an input template with an output cluster.\n\n\nFields\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncluster_id\n\n\nJaniceClusterId\n\n\nA unique identifier for the cluster this item belongs to. Items belonging to the same cluster should have the same \ncluster_id\n\n\n\n\n\n\ntmpl_id\n\n\nJaniceTemplateId\n\n\nA unique identifier for the template object this item corresponds to.\n\n\n\n\n\n\nconfidence\n\n\ndouble\n\n\nThe confidence that this item belongs to this cluster.", 
            "title": "Structs"
        }, 
        {
            "location": "/api/clustering/structs/#JaniceMediaClusterItem", 
            "text": "A structure that connects an input media and location with an output cluster.\nBecause multiple detections could occur in a single piece of media a JaniceRect  and a frame index are included\nto identify which detection this item refers to.", 
            "title": "JaniceMediaClusterItem"
        }, 
        {
            "location": "/api/clustering/structs/#JaniceMediaClusterItemFields", 
            "text": "Name  Type  Description      cluster_id  JaniceClusterId  A unique identifier for the cluster this item belongs to. Items belonging to the same cluster should have the same  cluster_id    media_id  JaniceMediaId  A unique identifier for the media object this item corresponds to.    confidence  double  The confidence that this item belongs to this cluster.    rect  JaniceRect  The location of the clustered object in a frame or image.    frame  uint32_t  The frame index of the clustered object if the media is a video, otherwise 0.", 
            "title": "Fields"
        }, 
        {
            "location": "/api/clustering/structs/#JaniceTemplateClusterItem", 
            "text": "A structure that connects an input template with an output cluster.", 
            "title": "JaniceTemplateClusterItem"
        }, 
        {
            "location": "/api/clustering/structs/#JaniceTemplateClusterItemFields", 
            "text": "Name  Type  Description      cluster_id  JaniceClusterId  A unique identifier for the cluster this item belongs to. Items belonging to the same cluster should have the same  cluster_id    tmpl_id  JaniceTemplateId  A unique identifier for the template object this item corresponds to.    confidence  double  The confidence that this item belongs to this cluster.", 
            "title": "Fields"
        }, 
        {
            "location": "/api/clustering/typedefs/", 
            "text": "JaniceClusterId\n\n\nA unique identifier for a cluster\n\n\nSignature\n\n\ntypedef uint32_t JaniceClusterId;\n\n\n\n\nJaniceMediaId\n\n\nA unique identifier for a media object\n\n\nSignature\n\n\ntypedef uint32_t JaniceMediaId;\n\n\n\n\nJaniceMediaIds\n\n\nAn array of \nJaniceMediaId\n objects.\n\n\nSignature\n\n\ntypedef JaniceMediaId* JaniceMediaIds;\n\n\n\n\nJaniceMediaClusterItems\n\n\nAn array of \nJaniceMediaClusterItem\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceMediaClusterItem* JaniceMediaClusterItems;\n\n\n\n\nJaniceTemplateClusterItems\n\n\nAn array of \nJaniceTemplateClusterItem\n objects.\n\n\nSignature\n\n\ntypedef struct JaniceTemplateClusterItem* JaniceTemplateClusterItems;", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceClusterId", 
            "text": "A unique identifier for a cluster", 
            "title": "JaniceClusterId"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceClusterIdSignature", 
            "text": "typedef uint32_t JaniceClusterId;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaId", 
            "text": "A unique identifier for a media object", 
            "title": "JaniceMediaId"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaIdSignature", 
            "text": "typedef uint32_t JaniceMediaId;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaIds", 
            "text": "An array of  JaniceMediaId  objects.", 
            "title": "JaniceMediaIds"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaIdsSignature", 
            "text": "typedef JaniceMediaId* JaniceMediaIds;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaClusterItems", 
            "text": "An array of  JaniceMediaClusterItem  objects.", 
            "title": "JaniceMediaClusterItems"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceMediaClusterItemsSignature", 
            "text": "typedef struct JaniceMediaClusterItem* JaniceMediaClusterItems;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceTemplateClusterItems", 
            "text": "An array of  JaniceTemplateClusterItem  objects.", 
            "title": "JaniceTemplateClusterItems"
        }, 
        {
            "location": "/api/clustering/typedefs/#JaniceTemplateClusterItemsSignature", 
            "text": "typedef struct JaniceTemplateClusterItem* JaniceTemplateClusterItems;", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/functions/", 
            "text": "janice_cluster_media\n\n\nCluster a collection of media objects into groups. Each media object may\ncontain 0 or more objects of interest. To distinguish between these objects\nthe output cluster contains an object location.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_cluster_media(JaniceConstMedias input,\n                                               const JaniceMediaIds input_ids,\n                                               uint32_t num_inputs,\n                                               uint32_t hint,\n                                               JaniceMediaClusterItems* clusters,\n                                               uint32_t* num_clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nHint\n\n\nClustering is generally considered to be an ill-defined problem, and most\nalgorithms require some help determining the appropriate number of clusters.\nThe hint parameter helps influence the number of clusters, though the\nimplementation is free to ignore it. The goal of the hint is to provide user\ninput for two use cases:\n\n\n\n\nIf the hint is between 0 - 1 it should be regarded as a purity requirement for the algorithm. A 1 indicates the user wants perfectly pure clusters, even if that means more clusters are returned. A 0 indicates that the user wants very few clusters returned and accepts there may be some errors.\n\n\nIf the hint is \n 1 it represents an estimated upper bound on the number of object types in the set.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nJaniceConstMedias\n\n\nAn array of media objects to cluster\n\n\n\n\n\n\ninput_ids\n\n\nconst \nJaniceMediaIds\n\n\nAn array of unique identifiers for the input objects. This array must be the same size as \ninput\n and the \nith\n id corresponds to the \nith\n media object in the input.\n\n\n\n\n\n\nnum_inputs\n\n\nuint32_t\n\n\nThe size of both the input and input_ids arrays.\n\n\n\n\n\n\nhint\n\n\nuint32_t\n\n\nA \nhint\n to the clustering algorithm.\n\n\n\n\n\n\nclusters\n\n\nJaniceMediaClusterItems*\n\n\nAn uninitialized array to hold the cluster output.\n\n\n\n\n\n\nnum_clusters\n\n\nuint32_t*\n\n\nThe size of the \nclusters\n array.\n\n\n\n\n\n\n\n\njanice_cluster_templates\n\n\nCluster a collection of template objects into groups.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_cluster_templates(JaniceConstTemplates input,\n                                                   const JaniceTemplateIds input_ids,\n                                                   uint32_t num_inputs,\n                                                   uint32_t hint,\n                                                   JaniceTemplateClusterItems* clusters,\n                                                   uint32_t* num_clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nJaniceConstTemplates\n\n\nAn array of template objects to cluster\n\n\n\n\n\n\ninput_ids\n\n\nconst \nJaniceTemplateIds\n\n\nAn array of unique identifiers for the input objects. This array must be the same size as \ninput\n and the \nith\n id corresponds to the \nith\n media object in the input.\n\n\n\n\n\n\nnum_inputs\n\n\nuint32_t\n\n\nThe size of both the input and input_ids arrays.\n\n\n\n\n\n\nhint\n\n\nuint32_t\n\n\nA \nhint\n to the clustering algorithm.\n\n\n\n\n\n\nclusters\n\n\nJaniceTemplateClusterItems*\n\n\nAn uninitialized array to hold the cluster output.\n\n\n\n\n\n\nnum_clusters\n\n\nuint32_t*\n\n\nThe size of the \nclusters\n array.\n\n\n\n\n\n\n\n\njanice_free_media_cluster_items\n\n\nFree any memory associated with a \nJaniceMediaClusterItems\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_media_cluster_items(JaniceMediaClusterItems* clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nclusters\n\n\nJaniceMediaClusterItems*\n\n\nThe object to free\n\n\n\n\n\n\n\n\njanice_free_template_cluster_items\n\n\nFree any memory associated with a \nJaniceTemplateClusterItems\n object.\n\n\nSignature\n\n\nJANICE_EXPORT JaniceError janice_free_template_cluster_items(JaniceTemplateClusterItems* clusters);\n\n\n\n\nThread Safety\n\n\nThis function is reentrant.\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nclusters\n\n\nJaniceTemplateClusterItems*\n\n\nThe object to free", 
            "title": "Functions"
        }, 
        {
            "location": "/api/clustering/functions/#janice_cluster_media", 
            "text": "Cluster a collection of media objects into groups. Each media object may\ncontain 0 or more objects of interest. To distinguish between these objects\nthe output cluster contains an object location.", 
            "title": "janice_cluster_media"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterMediaSignature", 
            "text": "JANICE_EXPORT JaniceError janice_cluster_media(JaniceConstMedias input,\n                                               const JaniceMediaIds input_ids,\n                                               uint32_t num_inputs,\n                                               uint32_t hint,\n                                               JaniceMediaClusterItems* clusters,\n                                               uint32_t* num_clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterMediaThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterMediaHint", 
            "text": "Clustering is generally considered to be an ill-defined problem, and most\nalgorithms require some help determining the appropriate number of clusters.\nThe hint parameter helps influence the number of clusters, though the\nimplementation is free to ignore it. The goal of the hint is to provide user\ninput for two use cases:   If the hint is between 0 - 1 it should be regarded as a purity requirement for the algorithm. A 1 indicates the user wants perfectly pure clusters, even if that means more clusters are returned. A 0 indicates that the user wants very few clusters returned and accepts there may be some errors.  If the hint is   1 it represents an estimated upper bound on the number of object types in the set.", 
            "title": "Hint"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterMediaParameters", 
            "text": "Name  Type  Description      input  JaniceConstMedias  An array of media objects to cluster    input_ids  const  JaniceMediaIds  An array of unique identifiers for the input objects. This array must be the same size as  input  and the  ith  id corresponds to the  ith  media object in the input.    num_inputs  uint32_t  The size of both the input and input_ids arrays.    hint  uint32_t  A  hint  to the clustering algorithm.    clusters  JaniceMediaClusterItems*  An uninitialized array to hold the cluster output.    num_clusters  uint32_t*  The size of the  clusters  array.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterTemplates", 
            "text": "Cluster a collection of template objects into groups.", 
            "title": "janice_cluster_templates"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterTemplatesSignature", 
            "text": "JANICE_EXPORT JaniceError janice_cluster_templates(JaniceConstTemplates input,\n                                                   const JaniceTemplateIds input_ids,\n                                                   uint32_t num_inputs,\n                                                   uint32_t hint,\n                                                   JaniceTemplateClusterItems* clusters,\n                                                   uint32_t* num_clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterTemplatesThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceClusterTemplatesParameters", 
            "text": "Name  Type  Description      input  JaniceConstTemplates  An array of template objects to cluster    input_ids  const  JaniceTemplateIds  An array of unique identifiers for the input objects. This array must be the same size as  input  and the  ith  id corresponds to the  ith  media object in the input.    num_inputs  uint32_t  The size of both the input and input_ids arrays.    hint  uint32_t  A  hint  to the clustering algorithm.    clusters  JaniceTemplateClusterItems*  An uninitialized array to hold the cluster output.    num_clusters  uint32_t*  The size of the  clusters  array.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeMediaClusterItems", 
            "text": "Free any memory associated with a  JaniceMediaClusterItems  object.", 
            "title": "janice_free_media_cluster_items"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeMediaClusterItemsSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_media_cluster_items(JaniceMediaClusterItems* clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeMediaClusterItemsThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeMediaClusterItemsParameters", 
            "text": "Name  Type  Description      clusters  JaniceMediaClusterItems*  The object to free", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeTemplateClusterItems", 
            "text": "Free any memory associated with a  JaniceTemplateClusterItems  object.", 
            "title": "janice_free_template_cluster_items"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeTemplateClusterItemsSignature", 
            "text": "JANICE_EXPORT JaniceError janice_free_template_cluster_items(JaniceTemplateClusterItems* clusters);", 
            "title": "Signature"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeTemplateClusterItemsThreadSafety", 
            "text": "This function is reentrant.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/api/clustering/functions/#JaniceFreeTemplateClusterItemsParameters", 
            "text": "Name  Type  Description      clusters  JaniceTemplateClusterItems*  The object to free", 
            "title": "Parameters"
        }, 
        {
            "location": "/interfaces/cpp/", 
            "text": "WORK IN PROGRESS", 
            "title": "C++"
        }, 
        {
            "location": "/interfaces/cpp/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/python/", 
            "text": "WORK IN PROGRESS", 
            "title": "Python"
        }, 
        {
            "location": "/interfaces/python/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/csharp/", 
            "text": "WORK IN PROGRESS", 
            "title": "C#"
        }, 
        {
            "location": "/interfaces/csharp/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/interfaces/java/", 
            "text": "WORK IN PROGRESS", 
            "title": "Java"
        }, 
        {
            "location": "/interfaces/java/#work-in-progress", 
            "text": "", 
            "title": "WORK IN PROGRESS"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "/*******************************************************************************\n * Copyright (c) 2013 Noblis, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and/or associated documentation files (the\n * \nMaterials\n), to deal in the Materials without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Materials, and to\n * permit persons to whom the Materials are furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Materials.\n *\n * THE MATERIALS ARE PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n ******************************************************************************/", 
            "title": "License"
        }
    ]
}