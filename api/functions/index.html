<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Noblis">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Functions - JanICE</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Functions";
    var mkdocs_page_input_path = "api/functions.md";
    var mkdocs_page_url = "/api/functions/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> JanICE</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Overview</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>API</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../cv_concepts/">Computer Vision Concepts</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../software_concepts/">Software Concepts</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../enums/">Enumerations</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../objects/">Objects</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Functions</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#overview">Overview</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceInitialize">janice_initialize</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceTrain">janice_train</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceErrorToString">janice_error_to_string</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceSDKVersion">janice_sdk_version</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceCreateMedia">janice_create_media</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceFreeMedia">janice_free_media</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceCreateDetection">janice_create_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceDetect">janice_detect</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceDetectionGetInstances">janice_detection_get_instances</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceSerializeDetection">janice_serialize_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceDeserializeDetection">janice_deserialize_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceReadDetection">janice_read_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceWriteDetection">janice_write_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceFreeDetection">janice_free_detection</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceCreateTemplate">janice_create_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceSerializeTemplate">janice_serialize_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceDeserializeTemplate">janice_deserialize_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceReadTemplate">janice_read_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceWriteTemplate">janice_write_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceFreeTemplate">janice_free_template</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceVerify">janice_verify</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceCreateGallery">janice_create_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceGalleryInsert">janice_gallery_insert</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceGalleryRemove">janice_gallery_remove</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceGalleryPrepare">janice_gallery_prepare</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceSerializeGallery">janice_serialize_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceDeserializeGallery">janice_deserialize_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceReadGallery">janice_read_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceWriteGallery">janice_write_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceFreeGallery">janice_free_gallery</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceSearch">janice_search</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceClusterMedia">janice_cluster_media</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceClusterTemplates">janice_cluster_templates</a></li>
                
                    <li><a class="toctree-l4" href="#JaniceFinalize">janice_finalize</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Interfaces</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../interfaces/cpp/">C++</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../interfaces/python/">Python</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../interfaces/csharp/">C#</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../interfaces/java/">Java</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../LICENSE/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">JanICE</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>API &raquo;</li>
        
      
    
    <li>Functions</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/Noblis/janice/edit/master/docs/api/functions.md"
          class="icon icon-github"> Edit on Github</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="overview">Overview</h1>
<p>There are a number of use cases associated with this API. The meaning of the
concepts this API tries to convey changes depending on the use case. In the
following documentation, if the use of the function changes depending on the
use case, the description will clearly state what the use is for each relevant
use case. If the use of the function does not change, a single description will
be provided.</p>
<p>All API functions return an <a href="../enums/#JaniceError">error code</a>. Because it is universal
the return type is not stated in the following documentation.</p>
<h2 id="JaniceInitialize">janice_initialize</h2>
<p>Initialize global or shared state for the implementation. This function should
be called once at the start of the application, before making any other calls
to the API.</p>
<h3 id="JaniceInitializeSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_initialize(const char* sdk_path,
                                            const char* temp_path,
                                            const char* algorithm,
                                            const int gpu_dev);</code></pre>


<h3 id="JaniceInitializeThreadSafety">Thread Safety</h3>
<p>This function is thread unsafe.</p>
<h3 id="JaniceInitializeParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdk_path</td>
<td>const char*</td>
<td>Path to a <em>read-only</em> directory containing the JanICE compliant SDK as specified by the implementor</td>
</tr>
<tr>
<td>temp_path</td>
<td>const char*</td>
<td>Path to an existing empty <em>read-write</em> directory for use as temporary file storage by the implementation. This path must be guaranteed until <a href="#JaniceFinalize">janice_finalize</a>.</td>
</tr>
<tr>
<td>algorithm</td>
<td>const char*</td>
<td>An empty string indicating the a default algorithm, or an implementation defined string containing an alternative configuration</td>
</tr>
<tr>
<td>gpu_dev</td>
<td>int</td>
<td>An index indicated a GPU device to use. If no GPU is available users should pass -1. If implementors do not offer a GPU solution they can ignore this value.</td>
</tr>
</tbody>
</table>
<h2 id="JaniceTrain">janice_train</h2>
<p>Train an implementation using new data.</p>
<h3 id="JaniceTrainSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_train(const char* data_prefix,
                                       const char* data_list);</code></pre>


<h3 id="JaniceTrainThreadSafety">Thread Safety</h3>
<p>This function is thread unsafe.</p>
<h3 id="JaniceTrainParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data_prefix</td>
<td>const char*</td>
<td>A prefix path pointing to the location of training data</td>
</tr>
<tr>
<td>data_train</td>
<td>const char*</td>
<td>A list of training data and labels. The format is currently unspecified</td>
</tr>
</tbody>
</table>
<h3 id="JaniceTrainNotes">Notes</h3>
<p>This function is untested, unstable and most likely subject to breaking changes
in future releases.</p>
<h2 id="JaniceErrorToString">janice_error_to_string</h2>
<p>Convert an <a href="../enums/#JaniceError">error code</a> into a string for printing.</p>
<h3 id="JaniceErrorToStringSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT const char* janice_error_to_string(JaniceError error);</code></pre>


<h3 id="JaniceErrorToStringThreadSafety">Thread Safety</h3>
<p>This function is thread safe.</p>
<h3 id="JaniceErrorToStringParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>error</td>
<td><a href="../enums/#JaniceError">JaniceError</a></td>
<td>An error code</td>
</tr>
</tbody>
</table>
<h3 id="JaniceErrorToStringReturnValue">Return Value</h3>
<p>This is the only function in the API that does not return
<a href="../enums/#JaniceError">JaniceError</a>. It returns <code>const char*</code> which is a
null-terminated list of characters that describe the input error.</p>
<h2 id="JaniceSDKVersion">janice_sdk_version</h2>
<p>Query the implementation for the version of the API it was designed to
implement. See <a href="../software_concepts/#Versioning">the section on software versioning</a> for more
information on the versioning process for this API.</p>
<h3 id="JaniceSDKVersionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_sdk_version(uint32_t* major,
                                             uint32_t* minor,
                                             uint32_t* patch);</code></pre>


<h3 id="JaniceSDKVersionThreadSafety">Thread Safety</h3>
<p>This function is thread safe.</p>
<h3 id="parameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>major</td>
<td>uint32_t*</td>
<td>The supported major version of the API</td>
</tr>
<tr>
<td>minor</td>
<td>uint32_t*</td>
<td>The supported minor version of the API</td>
</tr>
<tr>
<td>patch</td>
<td>uint32_t*</td>
<td>The supported patch version of the API</td>
</tr>
</tbody>
</table>
<h2 id="JaniceCreateMedia">janice_create_media</h2>
<p>Create a <a href="../objects/#JaniceMediaType">JaniceMediaType</a> object from a file.</p>
<h3 id="JaniceCreateMediaSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_create_media(const char* filename,
                                              JaniceMedia* media);</code></pre>


<h3 id="JaniceCreateMediaThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceCreateMediaParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>const char*</td>
<td>A path to an image or video on disk</td>
</tr>
<tr>
<td>media</td>
<td><a href="../objects/#JaniceMediaType">JaniceMedia*</a></td>
<td>An uninitialized pointer to a media object.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceCreateMediaExample">Example</h3>
<pre class="code"><code>JaniceMedia media = NULL;
if (janice_create_media(&quot;example.media&quot;, &amp;media) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceFreeMedia">janice_free_media</h2>
<p>Free any memory associated with a <a href="../objects/#JaniceMediaType">JaniceMediaType</a> object.</p>
<h3 id="JaniceFreeMediaSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_free_media(JaniceMedia* media);</code></pre>


<h3 id="JaniceFreeMediaThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceFreeMediaParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>media</td>
<td><a href="../objects/#JaniceMediaType">JaniceMedia*</a></td>
<td>A media object to free. Best practice dictates the pointer should be set to <code>NULL</code> after it is freed.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceFreeMediaExample">Example</h3>
<pre class="code"><code>JaniceMedia media; // Where media is a valid media object created previously
if (janice_free_media(&amp;media) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceCreateDetection">janice_create_detection</h2>
<p>Create a detection from a known rectangle. This is useful if a human has
indentified an object of interest and would like to run subsequent API
functions on it. In the case where the input media is a video the given
rectangle is considered an initial sighting of the object of interest. The
implementation may detect additional sightings of the object in successive
frames.</p>
<h3 id="JaniceCreateDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_create_detection(JaniceConstMedia media,
                                                  const JaniceRect rect,
                                                  uint32_t frame,
                                                  JaniceDetection* detection);</code></pre>


<h3 id="JaniceCreateDetectionThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceCreateDetectionFaceRecognition">Face Recognition</h3>
<p>The provided rectangle will encapsulate a face in the media.</p>
<h3 id="JaniceCreateDetectionCameraIdentification">Camera Identification</h3>
<p>The provided rectangle will encapsulate a region of interest in the media. Often the
rectangle will simply border the entire image. Note that at this time camera
identification is only implemented for images and will return an error if the
media is a video. Because the implementation is image-only the value in the
frame parameter is ignored.</p>
<h3 id="JaniceCreateDetectionParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>media</td>
<td><a href="../objects/#JaniceMediaType">JaniceConstMedia</a></td>
<td>A media object to create the detection from</td>
</tr>
<tr>
<td>rect</td>
<td>const <a href="../objects/#JaniceRect">JaniceRect</a></td>
<td>A rectangle that bounds the object of interest</td>
</tr>
<tr>
<td>frame</td>
<td>uint32_t</td>
<td>An index to the frame in the media the rectangle refers to. If the media is an image this should be 0.</td>
</tr>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceDetection*</a></td>
<td>An uninitialized pointer to a detection object.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceCreateDetectionExample">Example</h3>
<pre class="code"><code>JaniceMedia media; // Where media is a valid media object created previously

JaniceRect rect; // Create a bounding rectangle around an object of interest
rect.x      = 10; // The rectangle should fall within the bounds of the media
rect.y      = 10; // This code assumes media width &gt; 110 and media height &gt; 110
rect.width  = 100;
rect.height = 100;

JaniceDetection detection = NULL; // best practice to initialize to NULL
if (janice_create_detection(media, rect, 0 /* frame */, &amp;detection) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceDetect">janice_detect</h2>
<p>Automatically detect objects in a media object. See <a href="../cv_concepts/#Detection">the paragraph on
detection</a> for an overview of detection in the context of this API.</p>
<h3 id="JaniceDetectSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_detect(JaniceConstMedia media,
                                        uint32_t min_object_size,
                                        JaniceDetection* detections,
                                        uint32_t* num_detections);</code></pre>


<h3 id="JaniceDetectThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceDetectMinimumObjectSize">Minimum Object Size</h3>
<p>This function specifies a minimum object size as one of its parameters. This
value indicates the minimum size of objects that the user would like to see
detected. Often, increasing the minimum size can improve runtime of algorithms.
The size is in pixels and corresponds to the length of the smaller side of the
rectangle. This means a detection will be returned if and only if its smaller
side is larger than the value specified. If the user does not wish to specify a
minimum width 0 can be provided.</p>
<h3 id="JaniceDetectFaceRecognition">Face Recogntion</h3>
<p>This function detects faces in the media.</p>
<h3 id="JaniceDetectCameraIdentification">Camera Identification</h3>
<p>This function provides a list of size 1 where the only entry is a detection
with a rect that encapsulates the entire image.</p>
<h3 id="JaniceDetectParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>media</td>
<td><a href="../objects/#JaniceMediaType">JaniceConstMedia</a></td>
<td>A media object to create the detection from.</td>
</tr>
<tr>
<td>min_object_size</td>
<td>uint32_t</td>
<td>A minimum object size. See <a href="#JaniceDetectMinimumObjectSize">Minimum Object Size</a></td>
</tr>
<tr>
<td>detections</td>
<td><a href="../objects/#JaniceDetectionType">JaniceDetection*</a></td>
<td>An uninitialized array to hold all of the detections detected in the media object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
<tr>
<td>num_detections</td>
<td>uint32_t*</td>
<td>The number of detections detected</td>
</tr>
</tbody>
</table>
<h3 id="JaniceDetectExample">Example</h3>
<pre class="code"><code>JaniceMedia media; // Where media is a valid media object created previously
const uint32_t min_object_size = 24; // Only find objects where the smaller
                                     // side is &gt; 24 pixels
JaniceDetection* detections = NULL; // best practice to initialize to NULL
uint32_t num_detections; // Will be populated with the size of detections

if (janice_detect(media, min_object_size, &amp;detections, &amp;num_detections) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceDetectionGetInstances">janice_detection_get_instances</h2>
<p>Get a list of the <a href="../objects/#JaniceDetectionInstance">JaniceDetectionInstances</a> that
comprise the detection.</p>
<h3 id="JaniceDetectionGetInstancesSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_detection_get_instances(JaniceConstDetection detection,
                                                         JaniceDetectionInstance** instances,
                                                         uint32_t* num_instances);</code></pre>


<h3 id="JaniceDetectionGetInstancesThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceDetectionGetInstancesParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceConstDetection</a></td>
<td>A detection object to get instances from</td>
</tr>
<tr>
<td>instances</td>
<td><a href="../objects/#JaniceDetectionInstance">JaniceDetectionInstance**</a></td>
<td>An uninitialized array to hold the instances that comprise the detection. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
<tr>
<td>num_instances</td>
<td>uint32_t*</td>
<td>The number of instances that comprise the detection</td>
</tr>
</tbody>
</table>
<h3 id="JaniceDetectionGetInstancesExample">Example</h3>
<pre class="code"><code>JaniceDetection detection; // Where detection is a valid detection object
                           // created previously
JaniceDetectionInstance* instances = NULL; // best practice to intialize to NULL
uint32_t num_instances; // Will be populated with the size of instances

if (janice_detection_get_instances(detection, &amp;instances, &amp;num_instances) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceSerializeDetection">janice_serialize_detection</h2>
<p>Serialize a <a href="../objects/#JaniceDetectionType">JaniceDetection</a> object to a flat buffer.</p>
<h3 id="JaniceSerializeDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_serialize_detection(JaniceConstDetection detection,
                                                     unsigned char** data,
                                                     size_t* len);</code></pre>


<h3 id="JaniceSerializeDetectionThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceSerializeDetectionParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceConstDetection</a></td>
<td>A detection object to serialize</td>
</tr>
<tr>
<td>data</td>
<td>unsigned char**</td>
<td>An uninitialized buffer to hold the flattened data. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
<tr>
<td>len</td>
<td>size_t*</td>
<td>The length of the flat buffer after it is filled.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceSerializeDetectionExample">Example</h3>
<pre class="code"><code>JaniceDetection detection; // Where detection is a valid detection created
                           // previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_detection(detection, &amp;buffer, &amp;buffer_len);</code></pre>


<h2 id="JaniceDeserializeDetection">janice_deserialize_detection</h2>
<p>Deserialize a <a href="../objects/#JaniceDetectionType">JaniceDetection</a> object from a flat buffer.</p>
<h3 id="JaniceDeserializeDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_deserialize_detection(const unsigned char* data,
                                                       size_t len,
                                                       JaniceDetection* detection);</code></pre>


<h3 id="JaniceDeserializeDetectionThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="parameters_1">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>const unsigned char*</td>
<td>A buffer containing data from a flattened detection object.</td>
</tr>
<tr>
<td>len</td>
<td>size_t</td>
<td>The length of the flat buffer</td>
</tr>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceDetection*</a></td>
<td>An uninitialized detection object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="example">Example</h3>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.detection&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceDetection detection = nullptr;
janice_deserialize_detection(buffer, buffer_len, detection);

fclose(file);</code></pre>


<h2 id="JaniceReadDetection">janice_read_detection</h2>
<p>Read a detection from a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.detection&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceDetection detection = nullptr;
janice_deserialize_detection(buffer, buffer_len, detection);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when reading from disk.</p>
<h3 id="JaniceReadDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_read_detection(const char* filename,
                                                JaniceDetection* detection);</code></pre>


<h3 id="JaniceReadDetectionThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceReadDetectionParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceDetection*</a></td>
<td>An uninitialized detection object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceReadDetectionExample">Example</h3>
<pre class="code"><code>JaniceDetection detection = NULL;
if (janice_read_detection(&quot;example.detection&quot;, &amp;detection) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceWriteDetection">janice_write_detection</h2>
<p>Write a detection to a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>JaniceDetection detection; // Where detection is a valid detection created
                           // previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_detection(detection, &amp;buffer, &amp;buffer_len);

FILE* file = fopen(&quot;serialized.detection&quot;, &quot;w+&quot;);
fwrite(buffer, 1, buffer_len, file);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when writing to disk.</p>
<h3 id="JaniceWriteDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_write_detection(JaniceConstDetection detection,
                                                 const char* filename);</code></pre>


<h3 id="JaniceWriteDetectionThreadSafety">ThreadSafety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceWriteDetectionParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceConstDetection</a></td>
<td>The detection object to write to disk</td>
</tr>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
</tbody>
</table>
<h3 id="JaniceWriteDetectionExample">Example</h3>
<pre class="code"><code>JaniceDetection detection; // Where detection is a valid detection created
                           // previously
if (janice_write_detection(detection, &quot;example.detection&quot;) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceFreeDetection">janice_free_detection</h2>
<p>Free any memory associated with a <a href="../objects/#JaniceDetectionType">JaniceDetectionType</a> object.</p>
<h3 id="JaniceFreeDetectionSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_free_detection(JaniceDetection* detection);</code></pre>


<h3 id="JaniceFreeDetectionThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceFreeDetectionParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>detection</td>
<td><a href="../objects/#JaniceDetectionType">JaniceDetection*</a></td>
<td>A detection object to free. Best practice dictates the pointer should be set to <code>NULL</code> after it is freed.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceFreeDetectionExample">Example</h3>
<pre class="code"><code>JaniceDetection detection; // Where detection is a valid detection object
                           // created previously
if (janice_free_detection(&amp;detection) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceCreateTemplate">janice_create_template</h2>
<p>Create a <a href="../objects/#JaniceTemplateType">JaniceTemplate</a> object from an array of detections.</p>
<h3 id="JaniceCreateTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_create_template(JaniceConstDetection* detections,
                                                 uint32_t num_detections,
                                                 JaniceEnrollmentType role,
                                                 JaniceTemplate* tmpl);</code></pre>


<h3 id="JaniceCreateTemplateThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceCreateTemplateParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>detections</td>
<td><a href="../objects/#JaniceDetectionType">JaniceConstDetection*</a></td>
<td>An array of detection objects</td>
</tr>
<tr>
<td>num_detections</td>
<td>uint32_t</td>
<td>The number of input detections</td>
</tr>
<tr>
<td>role</td>
<td><a href="../enums/#JaniceEnrollmentType">JaniceEnrollmentType</a></td>
<td>The use case for the template</td>
</tr>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceTemplate*</a></td>
<td>An uninitialized template object.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceCreateTemplateExample">Example</h3>
<pre class="code"><code>JaniceDetection* detections; // Where detections is a valid array of valid
                             // detection objects created previously
const uint32_t num_detections = K; // Where K is the number of detections in
                                   // the detections array
JaniceEnrollmentType role = Janice1NProbe; // This template will be used as a
                                           // probe in 1-N search
JaniceTemplate tmpl = NULL; // Best practice to initialize to NULL

if (janice_create_template(detections, num_detections, rolw, &amp;tmpl) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceSerializeTemplate">janice_serialize_template</h2>
<p>Serialize a <a href="../objects/#JaniceTemplateType">JaniceTemplate</a> object to a flat buffer.</p>
<h3 id="JaniceSerializeTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_serialize_template(JaniceConstTemplate tmpl,
                                                    unsigned char** data,
                                                    size_t* len);</code></pre>


<h3 id="JaniceSerializeTemplateThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceSerializeTemplateParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>A template object to serialize</td>
</tr>
<tr>
<td>data</td>
<td>unsigned char**</td>
<td>An uninitialized buffer to hold the flattened data. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
<tr>
<td>len</td>
<td>size_t*</td>
<td>The length of the flat buffer after it is filled.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceSerializeTemplateExample">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template created
                     // previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_template(tmpl, &amp;buffer, &amp;buffer_len);</code></pre>


<h2 id="JaniceDeserializeTemplate">janice_deserialize_template</h2>
<p>Deserialize a <a href="../objects/#JaniceTemplateType">JaniceTemplate</a> object from a flat buffer.</p>
<h3 id="JaniceDeserializeTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_deserialize_template(const unsigned char** data,
                                                      size_t len,
                                                      JaniceTemplate* tmpl);</code></pre>


<h3 id="JaniceDeserializeTemplateThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="parameters_2">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>const unsigned char*</td>
<td>A buffer containing data from a flattened template object.</td>
</tr>
<tr>
<td>len</td>
<td>size_t</td>
<td>The length of the flat buffer</td>
</tr>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceTemplate*</a></td>
<td>An uninitialized template object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="example_1">Example</h3>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.template&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceTemplate tmpl = NULL; // best practice to initialize to NULL
janice_deserialize_template(buffer, buffer_len, tmpl);

fclose(file);</code></pre>


<h2 id="JaniceReadTemplate">janice_read_template</h2>
<p>Read a template from a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.template&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceTemplate tmpl = nullptr;
janice_deserialize_template(buffer, buffer_len, tmpl);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when reading from disk.</p>
<h3 id="JaniceReadTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_read_template(const char* filename,
                                               JaniceTemplate* tmpl);</code></pre>


<h3 id="JaniceReadTemplateThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceReadTemplateParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceTemplate*</a></td>
<td>An uninitialized template object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceReadTemplateExample">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl = NULL;
if (janice_read_template(&quot;example.template&quot;, &amp;tmpl) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceWriteTemplate">janice_write_template</h2>
<p>Write a template to a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template created
                     // previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_template(tmpl, &amp;buffer, &amp;buffer_len);

FILE* file = fopen(&quot;serialized.template&quot;, &quot;w+&quot;);
fwrite(buffer, 1, buffer_len, file);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when writing to disk.</p>
<h3 id="JaniceWriteTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_write_template(JaniceConstTemplate tmpl,
                                                const char* filename);</code></pre>


<h3 id="JaniceWriteTemplateThreadSafety">ThreadSafety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceWriteTemplateParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>The template object to write to disk</td>
</tr>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
</tbody>
</table>
<h3 id="JaniceWriteTemplateExample">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template created
                     // previously
if (janice_write_template(tmpl, &quot;example.template&quot;) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceFreeTemplate">janice_free_template</h2>
<p>Free any memory associated with a <a href="../objects/#JaniceTemplateType">JaniceTemplateType</a> object.</p>
<h3 id="JaniceFreeTemplateSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_free_template(JaniceTemplate* tmpl);</code></pre>


<h3 id="JaniceFreeTemplateThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceFreeTemplateParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceTemplate*</a></td>
<td>A template object to free. Best practice dictates the pointer should be set to <code>NULL</code> after it is freed.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceFreeTemplateExample">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template object created previously
if (janice_free_template(&amp;tmpl) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceVerify">janice_verify</h2>
<p>Compare two templates with the difference expressed as a similarity score.</p>
<h3 id="JaniceVerifySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_verify(JaniceConstTemplate reference,
                                        JaniceConstTemplate verification,
                                        double* similarity);</code></pre>


<h3 id="JaniceVerifyThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceVerifySimilarityScore">Similarity Score</h3>
<p>This API expects that the comparison of two templates results in a single value
that quantifies the similarity between them. A similarity score is constrained
by the following requirements:</p>
<pre class="code"><code>1. Higher scores indicate greater similarity
2. Scores can be asymmetric. This mean verify(a, b) does not necessarily
   equal verify(b, a)</code></pre>


<h3 id="JaniceVerifyParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>reference</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>A reference template. This template was created with the <a href="#JaniceEnrollmentType">Janice11Reference</a> role.</td>
</tr>
<tr>
<td>verification</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>A verification template. This template was created with the <a href="../enums/#JaniceEnrollmentType">Janice11Verification</a> role.</td>
</tr>
<tr>
<td>similarity</td>
<td>double*</td>
<td>A similarity score. See <a href="#JaniceVerifySimilarityScore">this section</a> for more information.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceVerifyExample">Example</h3>
<pre class="code"><code>JaniceTemplate reference; // Where reference is a valid template object created
                          // previously
JaniceTemplate verification; // Where verification is a valid template object
                             // created previously
double similarity;
if (janice_verify(reference, verification, &amp;similarity) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceCreateGallery">janice_create_gallery</h2>
<p>Create a <a href="../objects/#JaniceGalleryType">JaniceGalleryType</a> object from a list of
templates and unique ids.</p>
<h3 id="JaniceCreateGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_create_gallery(JaniceConstTemplate* tmpls,
                                                const uint32_t* ids,
                                                JaniceGallery* gallery);</code></pre>


<h3 id="thread-safety-janicecreategallerythreadsafety">Thread Safety {: #JaniceCreateGalleryThreadSafety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceCreateGalleryParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tmpls</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate*</a></td>
<td>An array of templates to add to the gallery</td>
</tr>
<tr>
<td>ids</td>
<td>const uint32_t*</td>
<td>A set of unique identifiers to associate with the input templates. The <em>ith</em> id corresponds to the <em>ith</em> input template.</td>
</tr>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery*</a></td>
<td>An uninitialized gallery object.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceCreateGalleryExample">Example</h3>
<pre class="code"><code>JaniceTemplate* tmpls; // Where tmpls is a valid array of valid template
                       // objects created previously
uint32_t* ids; // Where ids is a valid array of unique unsigned integers that
               // is the same length as tmpls
JaniceGallery gallery = NULL; // best practice to initialize to NULL

if (janice_create_gallery(tmpls, ids, &amp;gallery) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceGalleryInsert">janice_gallery_insert</h2>
<p>Insert a template into a gallery object. The template data should be copied
into the gallery as the template may be deleted after this function.</p>
<h3 id="JaniceGalleryInsertSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_gallery_insert(JaniceGallery gallery,
                                                JaniceConstTemplate tmpl,
                                                uint32_t id);</code></pre>


<h3 id="JaniceGalleryInsertThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceGalleryInsertParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery</a></td>
<td>A gallery object to insert the template into.</td>
</tr>
<tr>
<td>tmpl</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>A template object to insert into the gallery.</td>
</tr>
<tr>
<td>id</td>
<td>uint32_t</td>
<td>A unique id to associate with the input template</td>
</tr>
</tbody>
</table>
<h3 id="JaniceGalleryInsertExample">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template object created
                     // previously
uint32_t id; // Where id is a unique integer to associate with tmpl. This
             // integer should not exist in the gallery
JaniceGallery gallery; // Where gallery is a valid gallery object created
                       // previously

if (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceGalleryRemove">janice_gallery_remove</h2>
<p>Remove a template from a gallery object using its unique id.</p>
<h3 id="JaniceGalleryRemoveSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_gallery_remove(JaniceGallery gallery,
                                                uint32_t id);</code></pre>


<h3 id="JaniceGalleryRemoveThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="parameters_3">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery</a></td>
<td>A gallery object to remove the template from</td>
</tr>
<tr>
<td>id</td>
<td>uint32_t</td>
<td>A unique id associated with a template in the gallery that indicates which template should be remove.</td>
</tr>
</tbody>
</table>
<h3 id="example_2">Example</h3>
<pre class="code"><code>JaniceTemplate tmpl; // Where tmpl is a valid template object created
                     // previously
const uint32_t id = 0; // A unique integer id to associate with tmpl.

JaniceGallery gallery; // Where gallery is a valid gallery object created
                       // previously that does not have a template with id '0'
                       // already inserted in it.

// Insert the template with id 0
if (janice_gallery_insert(gallery, tmpl, id) != JANICE_SUCCESS)
    // ERROR!

// Now we can remove the template
if (janice_gallery_remove(gallery, id) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceGalleryPrepare">janice_gallery_prepare</h2>
<p>Prepare a gallery for search. Implementors can use this function as an
opportunity to streamline gallery objects to accelerate the search process. The
calling convention for this function is <strong>NOT</strong> specified by the API, this
means that this function is not guaranteed to be called before
<a href="#JaniceSearch">janice_search</a>. It also means that templates can be added
to a gallery before and after this function is called. Implementations should
handle all of these calling conventions. However, users should be aware that
this function may be computationally expensive. They should strive to call it
only at critical junctions before search and as few times as possible overall.</p>
<h3 id="JaniceGalleryPrepareSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_gallery_prepare(JaniceGallery gallery);</code></pre>


<h3 id="JaniceGalleryPrepareThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceGalleryPrepareParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery</a></td>
<td>A gallery object to prepare</td>
</tr>
</tbody>
</table>
<h3 id="JaniceGalleryPrepareExample">Example</h3>
<pre class="code"><code>JaniceTemplate* tmpls; // Where tmpls is a valid array of valid template
                       // objects created previously
uint32_t* ids; // Where ids is a valid array of unique unsigned integers that
               // is the same length as tmpls
JaniceTemplate tmpl; // Where tmpl is a valid template object created
                     // previously
uint32_t id; // Where id is a unique integer id to associate with tmpl.

JaniceGallery gallery = NULL; // best practice to initialize to NULL

if (janice_create_gallery(tmpls, ids, &amp;gallery) != JANICE_SUCCESS)
    // ERROR!

// It is valid to run search without calling prepare
if (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)
    // ERROR!

// Prepare can be called after search
if (janice_gallery_prepare(gallery) != JANICE_SUCCESS)
    // ERROR!

// Search can be called again right after prepare
if (janice_search(tmpl, gallery ... ) != JANICE_SUCCESS)
    // ERROR!

// Insert another template into the gallery. This is valid after the gallery
// has been prepared
if (janice_gallery_insert(gallery, tmpl, 112) != JANICE_SUCCESS)
    // ERROR!

// Prepare the gallery again
if (janice_gallery_prepare(gallery) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceSerializeGallery">janice_serialize_gallery</h2>
<p>Serialize a <a href="../objects/#JaniceGalleryType">JaniceGallery</a> object to a flat buffer.</p>
<h3 id="JaniceSerializeGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_serialize_gallery(JaniceConstGallery gallery,
                                                   unsigned char** data,
                                                   size_t* len);</code></pre>


<h3 id="JaniceSerializeGalleryThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceSerializeGalleryParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceConstGallery</a></td>
<td>A gallery object to serialize</td>
</tr>
<tr>
<td>data</td>
<td>unsigned char**</td>
<td>An uninitialized buffer to hold the flattened data. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
<tr>
<td>len</td>
<td>size_t*</td>
<td>The length of the flat buffer after it is filled.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceSerializeGalleryExample">Example</h3>
<pre class="code"><code>JaniceGallery gallery; // Where gallery is a valid gallery created
                       // previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_gallery(gallery, &amp;buffer, &amp;buffer_len);</code></pre>


<h2 id="JaniceDeserializeGallery">janice_deserialize_gallery</h2>
<p>Deserialize a <a href="../objects/#JaniceGalleryType">JaniceGallery</a> object from a flat buffer.</p>
<h3 id="JaniceDeserializeGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_deserialize_gallery(const unsigned char** data,
                                                     size_t len,
                                                     JaniceGallery* gallery);</code></pre>


<h3 id="JaniceDeserializeGalleryThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="parameters_4">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>const unsigned char*</td>
<td>A buffer containing data from a flattened gallery object.</td>
</tr>
<tr>
<td>len</td>
<td>size_t</td>
<td>The length of the flat buffer</td>
</tr>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery*</a></td>
<td>An uninitialized gallery object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="example_3">Example</h3>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.gallery&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceGallery gallery = NULL; // best practice to initialize to NULL
janice_deserialize_gallery(buffer, buffer_len, gallery);

fclose(file);</code></pre>


<h2 id="JaniceReadGallery">janice_read_gallery</h2>
<p>Read a gallery from a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>const size_t buffer_len = K; // Where K is the known length of the buffer
unsigned char buffer[buffer_len];

FILE* file = fopen(&quot;serialized.gallery&quot;, &quot;r&quot;);
fread(buffer, 1, buffer_len, file);

JaniceGallery gallery = NULL; // best practice to initialize to NULL
janice_deserialize_gallery(buffer, buffer_len, gallery);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when reading from disk.</p>
<h3 id="JaniceReadGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_read_gallery(const char* filename,
                                              JaniceGallery* gallery);</code></pre>


<h3 id="JaniceReadGalleryThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceReadGalleryParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery*</a></td>
<td>An uninitialized gallery object. See <a href="../software_concepts/#MemoryAllocation">the section on memory allocation</a> for requirements for initialization.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceReadGalleryExample">Example</h3>
<pre class="code"><code>JaniceGallery gallery = NULL;
if (janice_read_gallery(&quot;example.gallery&quot;, &amp;gallery) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceWriteGallery">janice_write_gallery</h2>
<p>Write a gallery to a file on disk. This method is functionally equivalent
to the following-</p>
<pre class="code"><code>JaniceGallery gallery; // Where gallery is a valid gallery created previously.

unsigned char* buffer = NULL;
size_t buffer_len;
janice_serialize_gallery(gallery, &amp;buffer, &amp;buffer_len);

FILE* file = fopen(&quot;serialized.gallery&quot;, &quot;w+&quot;);
fwrite(buffer, 1, buffer_len, file);

fclose(file);</code></pre>


<p>It is provided for memory efficiency and ease of use when writing to disk.</p>
<h3 id="JaniceWriteGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_write_gallery(JaniceConstGallery gallery,
                                               const char* filename);</code></pre>


<h3 id="JaniceWriteGalleryThreadSafety">ThreadSafety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceWriteGalleryParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceConstGallery</a></td>
<td>The gallery object to write to disk</td>
</tr>
<tr>
<td>filename</td>
<td>const char*</td>
<td>The path to a file on disk</td>
</tr>
</tbody>
</table>
<h3 id="JaniceWriteGalleryExample">Example</h3>
<pre class="code"><code>JaniceGallery gallery; // Where gallery is a valid gallery created previously
if (janice_write_gallery(gallery, &quot;example.gallery&quot;) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceFreeGallery">janice_free_gallery</h2>
<p>Free any memory associated with a <a href="../objects/#JaniceGalleryType">JaniceGalleryType</a> object.</p>
<h3 id="JaniceFreeGallerySignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_free_gallery(JaniceGallery* gallery);</code></pre>


<h3 id="JaniceFreeGalleryThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceFreeGalleryParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceGallery*</a></td>
<td>A gallery object to free. Best practice dictates the pointer should be set to <code>NULL</code> after it is freed.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceFreeGalleryExample">Example</h3>
<pre class="code"><code>JaniceGallery gallery; // Where gallery is a valid gallery object created previously
if (janice_free_gallery(&amp;gallery) != JANICE_SUCCESS)
    // ERROR!</code></pre>


<h2 id="JaniceSearch">janice_search</h2>
<p>Compute 1-N search results between a query template object and a target gallery
object. The function allocates two arrays of equal size, one containing
<a href="#JaniceVerifySimilarityScore">similarity scores</a> and the other containing the
unique id of the template the score was computed with (along with the query).
Often it is desirable (and perhaps computationally efficient) to only see the
top K scores out of N possible templates. The option to set a K is provided to
the user as part of the function parameters.</p>
<h3 id="JaniceSearchSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_search(JaniceConstTemplate probe,
                                        JaniceConstGallery gallery,
                                        uint32_t num_requested,
                                        double** similarities,
                                        uint32_t** ids,
                                        uint32_t* num_returned);</code></pre>


<h3 id="JaniceSearchThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceSearchParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>probe</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate</a></td>
<td>A template object to use as a query</td>
</tr>
<tr>
<td>gallery</td>
<td><a href="../objects/#JaniceGalleryType">JaniceConstGallery</a></td>
<td>A gallery object to search against</td>
</tr>
<tr>
<td>num_requested</td>
<td>uint32_t</td>
<td>The number of requested returns. If the user would like as many returns as there are templates in the gallery they can pass this parameter with the value 0.</td>
</tr>
<tr>
<td>similarities</td>
<td>double**</td>
<td>An array of <a href="#JaniceVerifySimilarityScore">similarity scores</a>. The scores are expected to be sorted in descending order (i.e. the highest scores is stored at index 0).</td>
</tr>
<tr>
<td>ids</td>
<td>uint32_t**</td>
<td>An array of unique ids identifying the target templates associated with the similarity scores. This array must be the same size as the similarities array. The <em>ith</em> id corresponds with the <em>ith</em> similarity.</td>
</tr>
<tr>
<td>num_returned</td>
<td>uint32_t*</td>
<td>The number of elements in the similarities and ids arrays. This number can be different from <strong>num_requested</strong>.</td>
</tr>
</tbody>
</table>
<h3 id="JaniceSearchExample">Example</h3>
<pre class="code"><code>JaniceTemplate probe;  // Where probe is a valid template object created
                       // previously
JaniceGallery gallery; // Where gallery is a valid gallery object created
                       // previously
const uint32_t num_requested = 50; // Request the top 50 matches

double* similarities = NULL;
uint32_t* ids = NULL;
uint32_t num_returned;

// Run search
if (janice_search(probe, gallery, num_requested, &amp;similarities, &amp;ids, &amp;num_returned) != JANICE_SUCCESS)
    // ERROR!

num_requested == num_returned; // This might not be true!</code></pre>


<h2 id="JaniceClusterMedia">janice_cluster_media</h2>
<p>Cluster a collection of media objects into groups. Each media object may
contain 0 or more objects of interest. The resulting array of cluster items
must contain a detection object that indicates the object of interest being
referred to by the item.</p>
<h3 id="JaniceClusterMediaSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_cluster_media(JaniceConstMedia* input,
                                               const uint32_t* input_ids,
                                               const uint32_t num_inputs,
                                               const uint32_t hint,
                                               JaniceClusterItem** clusters);</code></pre>


<h3 id="JaniceClusterMediaThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="JaniceClusterMediaHint">Hint</h3>
<p>Clustering is generally considered to be an ill-defined problem, and most
algorithms require some help determining the appropriate number of clusters.
The hint parameter helps influence the number of clusters, though the
implementation is free to ignore it. The goal of the hint is to provide user
input for two use cases:</p>
<ol>
<li>If the hint is between 0 - 1 it should be regarded as a purity requirement for the algorithm. A 1 indicates the user wants perfectly pure clusters, even if that means more clusters are returned. A 0 indicates that the user wants very few clusters returned and accepts there may be some errors.</li>
<li>If the hint is &gt; 1 it represents an estimated upper bound on the number of object types in the set.</li>
</ol>
<h3 id="JaniceClusterMediaParameters">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td><a href="../objects/#JaniceMediaType">JaniceConstMedia*</a></td>
<td>An array of media objects.</td>
</tr>
<tr>
<td>input_ids</td>
<td>const uint32_t*</td>
<td>An array of unique ids for the input objects. This array must be the same size as input.</td>
</tr>
<tr>
<td>num_inputs</td>
<td>const uint32_t</td>
<td>The size of the input and input_ids arrays</td>
</tr>
<tr>
<td>hint</td>
<td>const uint32_t</td>
<td>See <a href="#JaniceClusterMediaHint">hint</a>.</td>
</tr>
<tr>
<td>clusters</td>
<td><a href="../objects/#JaniceClusterItem">JaniceClusterItem**</a></td>
<td>An uninitialized pointer to hold an array of cluster items.</td>
</tr>
<tr>
<td>num_clusters</td>
<td>uint32_t*</td>
<td>The size of the clusters array.</td>
</tr>
</tbody>
</table>
<h2 id="JaniceClusterTemplates">janice_cluster_templates</h2>
<p>Cluster a collection of previously enrolled templates into groups. The
templates must be enrolled with the <a href="../enums/#JaniceEnrollmentType">JaniceCluster</a> role.</p>
<h3 id="JaniceClusterTemplatesSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_cluster_templates(const JaniceTemplate* input,
                                                   const uint32_t* input_ids,
                                                   const uint32_t num_inputs,
                                                   const uint32_t hint,
                                                   JaniceClusterItem** clusters);</code></pre>


<h3 id="JaniceClusterTemplatesThreadSafety">Thread Safety</h3>
<p>This function is reentrant.</p>
<h3 id="parameters_5">Parameters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td><a href="../objects/#JaniceTemplateType">JaniceConstTemplate*</a></td>
<td>An array of template objects</td>
</tr>
<tr>
<td>input_ids</td>
<td>const uint32_t*</td>
<td>An array of unique ids for the input objects. This array must be the same size as input.</td>
</tr>
<tr>
<td>num_inputs</td>
<td>const uint32_t</td>
<td>The size of the input and input_ids arrays</td>
</tr>
<tr>
<td>hint</td>
<td>const uint32_t</td>
<td>See <a href="#JaniceClusterMediaHint">hint</a>.</td>
</tr>
<tr>
<td>clusters</td>
<td><a href="../objects/#JaniceClusterItem">JaniceClusterItem**</a></td>
<td>An uninitialized pointer to hold an array of cluster items.</td>
</tr>
<tr>
<td>num_clusters</td>
<td>uint32_t*</td>
<td>The size of the clusters array.</td>
</tr>
</tbody>
</table>
<h2 id="JaniceFinalize">janice_finalize</h2>
<p>Destroy any resources created by <a href="#JaniceInitialize">janice_initialize</a> and
finalize the application. This should be called once after all other API calls.</p>
<h3 id="JaniceFinalizeSignature">Signature</h3>
<pre class="code"><code>JANICE_EXPORT JaniceError janice_finalize();</code></pre>


<h3 id="thread-safety">Thread Safety</h3>
<p>This function is thread unsafe.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../interfaces/cpp/" class="btn btn-neutral float-right" title="C++">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../objects/" class="btn btn-neutral" title="Objects"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../objects/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../interfaces/cpp/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
